<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/* <a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2012, Regents of the University of Colorado <a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved.<a name="line.3"></a>
<span class="sourceLineNo">004</span> * <a name="line.4"></a>
<span class="sourceLineNo">005</span> * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<span class="sourceLineNo">006</span> * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<span class="sourceLineNo">007</span> * <a name="line.7"></a>
<span class="sourceLineNo">008</span> * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<span class="sourceLineNo">009</span> * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<span class="sourceLineNo">010</span> * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<span class="sourceLineNo">011</span> * <a name="line.11"></a>
<span class="sourceLineNo">012</span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<span class="sourceLineNo">013</span> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<span class="sourceLineNo">014</span> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<span class="sourceLineNo">015</span> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<span class="sourceLineNo">016</span> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<span class="sourceLineNo">017</span> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<span class="sourceLineNo">018</span> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<span class="sourceLineNo">019</span> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<span class="sourceLineNo">020</span> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<span class="sourceLineNo">021</span> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<span class="sourceLineNo">022</span> * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<span class="sourceLineNo">023</span> */<a name="line.23"></a>
<span class="sourceLineNo">024</span>package org.cleartk.eval;<a name="line.24"></a>
<span class="sourceLineNo">025</span><a name="line.25"></a>
<span class="sourceLineNo">026</span>import java.io.Serializable;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import java.util.ArrayList;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import java.util.Collection;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import java.util.Collections;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import java.util.HashMap;<a name="line.30"></a>
<span class="sourceLineNo">031</span>import java.util.HashSet;<a name="line.31"></a>
<span class="sourceLineNo">032</span>import java.util.List;<a name="line.32"></a>
<span class="sourceLineNo">033</span>import java.util.Map;<a name="line.33"></a>
<span class="sourceLineNo">034</span>import java.util.Set;<a name="line.34"></a>
<span class="sourceLineNo">035</span><a name="line.35"></a>
<span class="sourceLineNo">036</span>import org.apache.uima.cas.Feature;<a name="line.36"></a>
<span class="sourceLineNo">037</span>import org.apache.uima.jcas.cas.TOP;<a name="line.37"></a>
<span class="sourceLineNo">038</span>import org.apache.uima.jcas.tcas.Annotation;<a name="line.38"></a>
<span class="sourceLineNo">039</span>import org.cleartk.eval.util.ConfusionMatrix;<a name="line.39"></a>
<span class="sourceLineNo">040</span><a name="line.40"></a>
<span class="sourceLineNo">041</span>import com.google.common.base.Function;<a name="line.41"></a>
<span class="sourceLineNo">042</span>import com.google.common.base.Objects;<a name="line.42"></a>
<span class="sourceLineNo">043</span>import com.google.common.base.Objects.ToStringHelper;<a name="line.43"></a>
<span class="sourceLineNo">044</span>import com.google.common.collect.HashMultiset;<a name="line.44"></a>
<span class="sourceLineNo">045</span>import com.google.common.collect.Multiset;<a name="line.45"></a>
<span class="sourceLineNo">046</span><a name="line.46"></a>
<span class="sourceLineNo">047</span>/**<a name="line.47"></a>
<span class="sourceLineNo">048</span> * Stores statistics for comparing {@link Annotation}s extracted by a system to gold<a name="line.48"></a>
<span class="sourceLineNo">049</span> * {@link Annotation}s.<a name="line.49"></a>
<span class="sourceLineNo">050</span> * <a name="line.50"></a>
<span class="sourceLineNo">051</span> * &lt;br&gt;<a name="line.51"></a>
<span class="sourceLineNo">052</span> * Copyright (c) 2012, Regents of the University of Colorado &lt;br&gt;<a name="line.52"></a>
<span class="sourceLineNo">053</span> * All rights reserved.<a name="line.53"></a>
<span class="sourceLineNo">054</span> * <a name="line.54"></a>
<span class="sourceLineNo">055</span> * @author Steven Bethard<a name="line.55"></a>
<span class="sourceLineNo">056</span> */<a name="line.56"></a>
<span class="sourceLineNo">057</span>public class AnnotationStatistics&lt;OUTCOME_TYPE extends Comparable&lt;? super OUTCOME_TYPE&gt;&gt; implements<a name="line.57"></a>
<span class="sourceLineNo">058</span>    Serializable {<a name="line.58"></a>
<span class="sourceLineNo">059</span><a name="line.59"></a>
<span class="sourceLineNo">060</span>  private static final long serialVersionUID = 1L;<a name="line.60"></a>
<span class="sourceLineNo">061</span><a name="line.61"></a>
<span class="sourceLineNo">062</span>  private Multiset&lt;OUTCOME_TYPE&gt; referenceOutcomes;<a name="line.62"></a>
<span class="sourceLineNo">063</span><a name="line.63"></a>
<span class="sourceLineNo">064</span>  private Multiset&lt;OUTCOME_TYPE&gt; predictedOutcomes;<a name="line.64"></a>
<span class="sourceLineNo">065</span><a name="line.65"></a>
<span class="sourceLineNo">066</span>  private Multiset&lt;OUTCOME_TYPE&gt; correctOutcomes;<a name="line.66"></a>
<span class="sourceLineNo">067</span><a name="line.67"></a>
<span class="sourceLineNo">068</span>  private ConfusionMatrix&lt;OUTCOME_TYPE&gt; confusionMatrix;<a name="line.68"></a>
<span class="sourceLineNo">069</span><a name="line.69"></a>
<span class="sourceLineNo">070</span>  /**<a name="line.70"></a>
<span class="sourceLineNo">071</span>   * Creates a {@link Function} that converts an {@link Annotation} into a hashable representation<a name="line.71"></a>
<span class="sourceLineNo">072</span>   * of its begin and end offsets.<a name="line.72"></a>
<span class="sourceLineNo">073</span>   * <a name="line.73"></a>
<span class="sourceLineNo">074</span>   * The {@link Function} created by this method is suitable for passing to the first<a name="line.74"></a>
<span class="sourceLineNo">075</span>   * {@link Function} argument of {@link #add(Collection, Collection, Function, Function)}.<a name="line.75"></a>
<span class="sourceLineNo">076</span>   */<a name="line.76"></a>
<span class="sourceLineNo">077</span>  public static &lt;ANNOTATION_TYPE extends Annotation&gt; Function&lt;ANNOTATION_TYPE, Span&gt; annotationToSpan() {<a name="line.77"></a>
<span class="sourceLineNo">078</span>    return new Function&lt;ANNOTATION_TYPE, Span&gt;() {<a name="line.78"></a>
<span class="sourceLineNo">079</span>      @Override<a name="line.79"></a>
<span class="sourceLineNo">080</span>      public Span apply(ANNOTATION_TYPE annotation) {<a name="line.80"></a>
<span class="sourceLineNo">081</span>        return new Span(annotation);<a name="line.81"></a>
<span class="sourceLineNo">082</span>      }<a name="line.82"></a>
<span class="sourceLineNo">083</span>    };<a name="line.83"></a>
<span class="sourceLineNo">084</span>  }<a name="line.84"></a>
<span class="sourceLineNo">085</span><a name="line.85"></a>
<span class="sourceLineNo">086</span>  /**<a name="line.86"></a>
<span class="sourceLineNo">087</span>   * Creates a {@link Function} that extracts a feature value from a {@link TOP}.<a name="line.87"></a>
<span class="sourceLineNo">088</span>   * <a name="line.88"></a>
<span class="sourceLineNo">089</span>   * The {@link Function} created by this method is suitable for passing to the second<a name="line.89"></a>
<span class="sourceLineNo">090</span>   * {@link Function} argument of {@link #add(Collection, Collection, Function, Function)}.<a name="line.90"></a>
<span class="sourceLineNo">091</span>   * <a name="line.91"></a>
<span class="sourceLineNo">092</span>   * @param featureName<a name="line.92"></a>
<span class="sourceLineNo">093</span>   *          The name of the feature whose value is to be extracted.<a name="line.93"></a>
<span class="sourceLineNo">094</span>   */<a name="line.94"></a>
<span class="sourceLineNo">095</span>  public static &lt;ANNOTATION_TYPE extends TOP&gt; Function&lt;ANNOTATION_TYPE, String&gt; annotationToFeatureValue(<a name="line.95"></a>
<span class="sourceLineNo">096</span>      final String featureName) {<a name="line.96"></a>
<span class="sourceLineNo">097</span>    return new Function&lt;ANNOTATION_TYPE, String&gt;() {<a name="line.97"></a>
<span class="sourceLineNo">098</span>      @Override<a name="line.98"></a>
<span class="sourceLineNo">099</span>      public String apply(ANNOTATION_TYPE annotation) {<a name="line.99"></a>
<span class="sourceLineNo">100</span>        Feature feature = annotation.getType().getFeatureByBaseName(featureName);<a name="line.100"></a>
<span class="sourceLineNo">101</span>        return annotation.getFeatureValueAsString(feature);<a name="line.101"></a>
<span class="sourceLineNo">102</span>      }<a name="line.102"></a>
<span class="sourceLineNo">103</span>    };<a name="line.103"></a>
<span class="sourceLineNo">104</span>  }<a name="line.104"></a>
<span class="sourceLineNo">105</span><a name="line.105"></a>
<span class="sourceLineNo">106</span>  /**<a name="line.106"></a>
<span class="sourceLineNo">107</span>   * Creates a {@link Function} that always returns null.<a name="line.107"></a>
<span class="sourceLineNo">108</span>   * <a name="line.108"></a>
<span class="sourceLineNo">109</span>   * This may be useful when only the span of the offset is important, but you still need to pass in<a name="line.109"></a>
<span class="sourceLineNo">110</span>   * the final argument of {@link #add(Collection, Collection, Function, Function)}.<a name="line.110"></a>
<span class="sourceLineNo">111</span>   */<a name="line.111"></a>
<span class="sourceLineNo">112</span>  public static &lt;ANNOTATION_TYPE, OUTCOME_TYPE&gt; Function&lt;ANNOTATION_TYPE, OUTCOME_TYPE&gt; annotationToNull() {<a name="line.112"></a>
<span class="sourceLineNo">113</span>    return new Function&lt;ANNOTATION_TYPE, OUTCOME_TYPE&gt;() {<a name="line.113"></a>
<span class="sourceLineNo">114</span>      @Override<a name="line.114"></a>
<span class="sourceLineNo">115</span>      public OUTCOME_TYPE apply(ANNOTATION_TYPE annotation) {<a name="line.115"></a>
<span class="sourceLineNo">116</span>        return null;<a name="line.116"></a>
<span class="sourceLineNo">117</span>      }<a name="line.117"></a>
<span class="sourceLineNo">118</span>    };<a name="line.118"></a>
<span class="sourceLineNo">119</span>  }<a name="line.119"></a>
<span class="sourceLineNo">120</span><a name="line.120"></a>
<span class="sourceLineNo">121</span>  /**<a name="line.121"></a>
<span class="sourceLineNo">122</span>   * Add all statistics together.<a name="line.122"></a>
<span class="sourceLineNo">123</span>   * <a name="line.123"></a>
<span class="sourceLineNo">124</span>   * This is often useful for combining individual fold statistics that result from methods like<a name="line.124"></a>
<span class="sourceLineNo">125</span>   * {@link Evaluation_ImplBase#crossValidation(List, int)}.<a name="line.125"></a>
<span class="sourceLineNo">126</span>   * <a name="line.126"></a>
<span class="sourceLineNo">127</span>   * @param statistics<a name="line.127"></a>
<span class="sourceLineNo">128</span>   *          The sequence of statistics that should be combined.<a name="line.128"></a>
<span class="sourceLineNo">129</span>   * @return The combination of all the individual statistics.<a name="line.129"></a>
<span class="sourceLineNo">130</span>   */<a name="line.130"></a>
<span class="sourceLineNo">131</span>  public static &lt;OUTCOME_TYPE extends Comparable&lt;? super OUTCOME_TYPE&gt;&gt; AnnotationStatistics&lt;OUTCOME_TYPE&gt; addAll(<a name="line.131"></a>
<span class="sourceLineNo">132</span>      Iterable&lt;AnnotationStatistics&lt;OUTCOME_TYPE&gt;&gt; statistics) {<a name="line.132"></a>
<span class="sourceLineNo">133</span>    AnnotationStatistics&lt;OUTCOME_TYPE&gt; result = new AnnotationStatistics&lt;OUTCOME_TYPE&gt;();<a name="line.133"></a>
<span class="sourceLineNo">134</span>    for (AnnotationStatistics&lt;OUTCOME_TYPE&gt; item : statistics) {<a name="line.134"></a>
<span class="sourceLineNo">135</span>      result.addAll(item);<a name="line.135"></a>
<span class="sourceLineNo">136</span>    }<a name="line.136"></a>
<span class="sourceLineNo">137</span>    return result;<a name="line.137"></a>
<span class="sourceLineNo">138</span>  }<a name="line.138"></a>
<span class="sourceLineNo">139</span><a name="line.139"></a>
<span class="sourceLineNo">140</span>  /**<a name="line.140"></a>
<span class="sourceLineNo">141</span>   * Create an AnnotationStatistics that compares {@link Annotation}s based on their begin and end<a name="line.141"></a>
<span class="sourceLineNo">142</span>   * offsets, plus a {@link Feature} of the {@link Annotation} that represents the outcome or label.<a name="line.142"></a>
<span class="sourceLineNo">143</span>   */<a name="line.143"></a>
<span class="sourceLineNo">144</span>  public AnnotationStatistics() {<a name="line.144"></a>
<span class="sourceLineNo">145</span>    this.referenceOutcomes = HashMultiset.create();<a name="line.145"></a>
<span class="sourceLineNo">146</span>    this.predictedOutcomes = HashMultiset.create();<a name="line.146"></a>
<span class="sourceLineNo">147</span>    this.correctOutcomes = HashMultiset.create();<a name="line.147"></a>
<span class="sourceLineNo">148</span>    this.confusionMatrix = new ConfusionMatrix&lt;OUTCOME_TYPE&gt;();<a name="line.148"></a>
<span class="sourceLineNo">149</span>  }<a name="line.149"></a>
<span class="sourceLineNo">150</span><a name="line.150"></a>
<span class="sourceLineNo">151</span>  /**<a name="line.151"></a>
<span class="sourceLineNo">152</span>   * Update the statistics, comparing the reference annotations to the predicted annotations.<a name="line.152"></a>
<span class="sourceLineNo">153</span>   * <a name="line.153"></a>
<span class="sourceLineNo">154</span>   * Annotations are considered to match if they have the same character offsets in the text. All<a name="line.154"></a>
<span class="sourceLineNo">155</span>   * outcomes (e.g. as returned in {@link #confusions()}) will be &lt;code&gt;null&lt;/code&gt;.<a name="line.155"></a>
<span class="sourceLineNo">156</span>   * <a name="line.156"></a>
<span class="sourceLineNo">157</span>   * @param referenceAnnotations<a name="line.157"></a>
<span class="sourceLineNo">158</span>   *          The reference annotations, typically identified by humans.<a name="line.158"></a>
<span class="sourceLineNo">159</span>   * @param predictedAnnotations<a name="line.159"></a>
<span class="sourceLineNo">160</span>   *          The predicted annotations, typically identified by a model.<a name="line.160"></a>
<span class="sourceLineNo">161</span>   */<a name="line.161"></a>
<span class="sourceLineNo">162</span>  public &lt;ANNOTATION_TYPE extends Annotation&gt; void add(<a name="line.162"></a>
<span class="sourceLineNo">163</span>      Collection&lt;? extends ANNOTATION_TYPE&gt; referenceAnnotations,<a name="line.163"></a>
<span class="sourceLineNo">164</span>      Collection&lt;? extends ANNOTATION_TYPE&gt; predictedAnnotations) {<a name="line.164"></a>
<span class="sourceLineNo">165</span>    this.add(<a name="line.165"></a>
<span class="sourceLineNo">166</span>        referenceAnnotations,<a name="line.166"></a>
<span class="sourceLineNo">167</span>        predictedAnnotations,<a name="line.167"></a>
<span class="sourceLineNo">168</span>        AnnotationStatistics.&lt;ANNOTATION_TYPE&gt; annotationToSpan(),<a name="line.168"></a>
<span class="sourceLineNo">169</span>        AnnotationStatistics.&lt;ANNOTATION_TYPE, OUTCOME_TYPE&gt; annotationToNull());<a name="line.169"></a>
<span class="sourceLineNo">170</span>  }<a name="line.170"></a>
<span class="sourceLineNo">171</span><a name="line.171"></a>
<span class="sourceLineNo">172</span>  /**<a name="line.172"></a>
<span class="sourceLineNo">173</span>   * Update the statistics, comparing the reference annotations to the predicted annotations.<a name="line.173"></a>
<span class="sourceLineNo">174</span>   * <a name="line.174"></a>
<span class="sourceLineNo">175</span>   * Annotations are considered to match if they have the same span (according to<a name="line.175"></a>
<span class="sourceLineNo">176</span>   * {@code annotationToSpan}) and if they have the same outcome (according to<a name="line.176"></a>
<span class="sourceLineNo">177</span>   * {@code annotationToOutcome}).<a name="line.177"></a>
<span class="sourceLineNo">178</span>   * <a name="line.178"></a>
<span class="sourceLineNo">179</span>   * @param referenceAnnotations<a name="line.179"></a>
<span class="sourceLineNo">180</span>   *          The reference annotations, typically identified by humans.<a name="line.180"></a>
<span class="sourceLineNo">181</span>   * @param predictedAnnotations<a name="line.181"></a>
<span class="sourceLineNo">182</span>   *          The predicted annotations, typically identified by a model.<a name="line.182"></a>
<span class="sourceLineNo">183</span>   * @param annotationToSpan<a name="line.183"></a>
<span class="sourceLineNo">184</span>   *          A function that defines how to convert an annotation into a hashable object that<a name="line.184"></a>
<span class="sourceLineNo">185</span>   *          represents the span of that annotation. The {@link #annotationToSpan()} method<a name="line.185"></a>
<span class="sourceLineNo">186</span>   *          provides an example function that could be used here.<a name="line.186"></a>
<span class="sourceLineNo">187</span>   * @param annotationToOutcome<a name="line.187"></a>
<span class="sourceLineNo">188</span>   *          A function that defines how to convert an annotation into an object that represents<a name="line.188"></a>
<span class="sourceLineNo">189</span>   *          the outcome (or "label") assigned to that annotation. The<a name="line.189"></a>
<span class="sourceLineNo">190</span>   *          {@link #annotationToFeatureValue(String)} method provides a sample function that could<a name="line.190"></a>
<span class="sourceLineNo">191</span>   *          be used here.<a name="line.191"></a>
<span class="sourceLineNo">192</span>   */<a name="line.192"></a>
<span class="sourceLineNo">193</span>  public &lt;ANNOTATION_TYPE, SPAN_TYPE&gt; void add(<a name="line.193"></a>
<span class="sourceLineNo">194</span>      Collection&lt;? extends ANNOTATION_TYPE&gt; referenceAnnotations,<a name="line.194"></a>
<span class="sourceLineNo">195</span>      Collection&lt;? extends ANNOTATION_TYPE&gt; predictedAnnotations,<a name="line.195"></a>
<span class="sourceLineNo">196</span>      Function&lt;ANNOTATION_TYPE, SPAN_TYPE&gt; annotationToSpan,<a name="line.196"></a>
<span class="sourceLineNo">197</span>      Function&lt;ANNOTATION_TYPE, OUTCOME_TYPE&gt; annotationToOutcome) {<a name="line.197"></a>
<span class="sourceLineNo">198</span><a name="line.198"></a>
<span class="sourceLineNo">199</span>    // map gold spans to their outcomes<a name="line.199"></a>
<span class="sourceLineNo">200</span>    Map&lt;SPAN_TYPE, OUTCOME_TYPE&gt; referenceSpanOutcomes = new HashMap&lt;SPAN_TYPE, OUTCOME_TYPE&gt;();<a name="line.200"></a>
<span class="sourceLineNo">201</span>    for (ANNOTATION_TYPE ann : referenceAnnotations) {<a name="line.201"></a>
<span class="sourceLineNo">202</span>      referenceSpanOutcomes.put(annotationToSpan.apply(ann), annotationToOutcome.apply(ann));<a name="line.202"></a>
<span class="sourceLineNo">203</span>    }<a name="line.203"></a>
<span class="sourceLineNo">204</span><a name="line.204"></a>
<span class="sourceLineNo">205</span>    // map system spans to their outcomes<a name="line.205"></a>
<span class="sourceLineNo">206</span>    Map&lt;SPAN_TYPE, OUTCOME_TYPE&gt; predictedSpanOutcomes = new HashMap&lt;SPAN_TYPE, OUTCOME_TYPE&gt;();<a name="line.206"></a>
<span class="sourceLineNo">207</span>    for (ANNOTATION_TYPE ann : predictedAnnotations) {<a name="line.207"></a>
<span class="sourceLineNo">208</span>      predictedSpanOutcomes.put(annotationToSpan.apply(ann), annotationToOutcome.apply(ann));<a name="line.208"></a>
<span class="sourceLineNo">209</span>    }<a name="line.209"></a>
<span class="sourceLineNo">210</span><a name="line.210"></a>
<span class="sourceLineNo">211</span>    // update the gold and system outcomes<a name="line.211"></a>
<span class="sourceLineNo">212</span>    this.referenceOutcomes.addAll(referenceSpanOutcomes.values());<a name="line.212"></a>
<span class="sourceLineNo">213</span>    this.predictedOutcomes.addAll(predictedSpanOutcomes.values());<a name="line.213"></a>
<span class="sourceLineNo">214</span><a name="line.214"></a>
<span class="sourceLineNo">215</span>    // determine the outcomes that were correct<a name="line.215"></a>
<span class="sourceLineNo">216</span>    Set&lt;SPAN_TYPE&gt; intersection = new HashSet&lt;SPAN_TYPE&gt;();<a name="line.216"></a>
<span class="sourceLineNo">217</span>    intersection.addAll(referenceSpanOutcomes.keySet());<a name="line.217"></a>
<span class="sourceLineNo">218</span>    intersection.retainAll(predictedSpanOutcomes.keySet());<a name="line.218"></a>
<span class="sourceLineNo">219</span>    for (SPAN_TYPE span : intersection) {<a name="line.219"></a>
<span class="sourceLineNo">220</span>      OUTCOME_TYPE goldOutcome = referenceSpanOutcomes.get(span);<a name="line.220"></a>
<span class="sourceLineNo">221</span>      OUTCOME_TYPE systemOutcome = predictedSpanOutcomes.get(span);<a name="line.221"></a>
<span class="sourceLineNo">222</span>      if (Objects.equal(goldOutcome, systemOutcome)) {<a name="line.222"></a>
<span class="sourceLineNo">223</span>        this.correctOutcomes.add(goldOutcome);<a name="line.223"></a>
<span class="sourceLineNo">224</span>      }<a name="line.224"></a>
<span class="sourceLineNo">225</span>    }<a name="line.225"></a>
<span class="sourceLineNo">226</span><a name="line.226"></a>
<span class="sourceLineNo">227</span>    // update the confusion matrix<a name="line.227"></a>
<span class="sourceLineNo">228</span>    Set&lt;SPAN_TYPE&gt; union = new HashSet&lt;SPAN_TYPE&gt;();<a name="line.228"></a>
<span class="sourceLineNo">229</span>    union.addAll(referenceSpanOutcomes.keySet());<a name="line.229"></a>
<span class="sourceLineNo">230</span>    union.addAll(predictedSpanOutcomes.keySet());<a name="line.230"></a>
<span class="sourceLineNo">231</span>    for (SPAN_TYPE span : union) {<a name="line.231"></a>
<span class="sourceLineNo">232</span>      OUTCOME_TYPE goldOutcome = referenceSpanOutcomes.get(span);<a name="line.232"></a>
<span class="sourceLineNo">233</span>      OUTCOME_TYPE systemOutcome = predictedSpanOutcomes.get(span);<a name="line.233"></a>
<span class="sourceLineNo">234</span>      this.confusionMatrix.add(goldOutcome, systemOutcome);<a name="line.234"></a>
<span class="sourceLineNo">235</span>    }<a name="line.235"></a>
<span class="sourceLineNo">236</span>  }<a name="line.236"></a>
<span class="sourceLineNo">237</span><a name="line.237"></a>
<span class="sourceLineNo">238</span>  /**<a name="line.238"></a>
<span class="sourceLineNo">239</span>   * Adds all the statistics collected by another AnnotationStatistics to this one.<a name="line.239"></a>
<span class="sourceLineNo">240</span>   * <a name="line.240"></a>
<span class="sourceLineNo">241</span>   * @param that<a name="line.241"></a>
<span class="sourceLineNo">242</span>   *          The other statistics that should be added to this one.<a name="line.242"></a>
<span class="sourceLineNo">243</span>   */<a name="line.243"></a>
<span class="sourceLineNo">244</span>  public void addAll(AnnotationStatistics&lt;OUTCOME_TYPE&gt; that) {<a name="line.244"></a>
<span class="sourceLineNo">245</span>    this.referenceOutcomes.addAll(that.referenceOutcomes);<a name="line.245"></a>
<span class="sourceLineNo">246</span>    this.predictedOutcomes.addAll(that.predictedOutcomes);<a name="line.246"></a>
<span class="sourceLineNo">247</span>    this.correctOutcomes.addAll(that.correctOutcomes);<a name="line.247"></a>
<span class="sourceLineNo">248</span>    this.confusionMatrix.add(that.confusionMatrix);<a name="line.248"></a>
<span class="sourceLineNo">249</span>  }<a name="line.249"></a>
<span class="sourceLineNo">250</span><a name="line.250"></a>
<span class="sourceLineNo">251</span>  public int countCorrectOutcomes() {<a name="line.251"></a>
<span class="sourceLineNo">252</span>    return this.correctOutcomes.size();<a name="line.252"></a>
<span class="sourceLineNo">253</span>  }<a name="line.253"></a>
<span class="sourceLineNo">254</span><a name="line.254"></a>
<span class="sourceLineNo">255</span>  public int countCorrectOutcomes(OUTCOME_TYPE outcome) {<a name="line.255"></a>
<span class="sourceLineNo">256</span>    return this.correctOutcomes.count(outcome);<a name="line.256"></a>
<span class="sourceLineNo">257</span>  }<a name="line.257"></a>
<span class="sourceLineNo">258</span><a name="line.258"></a>
<span class="sourceLineNo">259</span>  public int countPredictedOutcomes() {<a name="line.259"></a>
<span class="sourceLineNo">260</span>    return this.predictedOutcomes.size();<a name="line.260"></a>
<span class="sourceLineNo">261</span>  }<a name="line.261"></a>
<span class="sourceLineNo">262</span><a name="line.262"></a>
<span class="sourceLineNo">263</span>  public int countPredictedOutcomes(OUTCOME_TYPE outcome) {<a name="line.263"></a>
<span class="sourceLineNo">264</span>    return this.predictedOutcomes.count(outcome);<a name="line.264"></a>
<span class="sourceLineNo">265</span>  }<a name="line.265"></a>
<span class="sourceLineNo">266</span><a name="line.266"></a>
<span class="sourceLineNo">267</span>  public int countReferenceOutcomes() {<a name="line.267"></a>
<span class="sourceLineNo">268</span>    return this.referenceOutcomes.size();<a name="line.268"></a>
<span class="sourceLineNo">269</span>  }<a name="line.269"></a>
<span class="sourceLineNo">270</span><a name="line.270"></a>
<span class="sourceLineNo">271</span>  public int countReferenceOutcomes(OUTCOME_TYPE outcome) {<a name="line.271"></a>
<span class="sourceLineNo">272</span>    return this.referenceOutcomes.count(outcome);<a name="line.272"></a>
<span class="sourceLineNo">273</span>  }<a name="line.273"></a>
<span class="sourceLineNo">274</span><a name="line.274"></a>
<span class="sourceLineNo">275</span>  public int countFalseNegatives(@SuppressWarnings("unchecked") OUTCOME_TYPE... positiveOutcomes) {<a name="line.275"></a>
<span class="sourceLineNo">276</span>    int numReferenceOutcomes = this.countReferenceOutcomes();<a name="line.276"></a>
<span class="sourceLineNo">277</span>    int numPredictedOutcomes = this.countPredictedOutcomes();<a name="line.277"></a>
<span class="sourceLineNo">278</span>    if (numReferenceOutcomes != numPredictedOutcomes) {<a name="line.278"></a>
<span class="sourceLineNo">279</span>      throw new IllegalStateException(<a name="line.279"></a>
<span class="sourceLineNo">280</span>          String.format(<a name="line.280"></a>
<span class="sourceLineNo">281</span>              "Expected number equal number of references outcomes and predicted outcomes.  Had reference outcomes=%d, predicted outcomes=%d",<a name="line.281"></a>
<span class="sourceLineNo">282</span>              numReferenceOutcomes,<a name="line.282"></a>
<span class="sourceLineNo">283</span>              numPredictedOutcomes,<a name="line.283"></a>
<span class="sourceLineNo">284</span>              this.countPredictedOutcomes()));<a name="line.284"></a>
<span class="sourceLineNo">285</span>    }<a name="line.285"></a>
<span class="sourceLineNo">286</span>    int totalFalseNegatives = 0;<a name="line.286"></a>
<span class="sourceLineNo">287</span>    for (OUTCOME_TYPE positiveOutcome : positiveOutcomes) {<a name="line.287"></a>
<span class="sourceLineNo">288</span>      totalFalseNegatives += this.countReferenceOutcomes(positiveOutcome)<a name="line.288"></a>
<span class="sourceLineNo">289</span>          - this.countCorrectOutcomes(positiveOutcome);<a name="line.289"></a>
<span class="sourceLineNo">290</span>    }<a name="line.290"></a>
<span class="sourceLineNo">291</span>    return totalFalseNegatives;<a name="line.291"></a>
<span class="sourceLineNo">292</span>  }<a name="line.292"></a>
<span class="sourceLineNo">293</span><a name="line.293"></a>
<span class="sourceLineNo">294</span>  public int countFalsePositives(@SuppressWarnings("unchecked") OUTCOME_TYPE... positiveOutcomes) {<a name="line.294"></a>
<span class="sourceLineNo">295</span>    int numReferenceOutcomes = this.countReferenceOutcomes();<a name="line.295"></a>
<span class="sourceLineNo">296</span>    int numPredictedOutcomes = this.countPredictedOutcomes();<a name="line.296"></a>
<span class="sourceLineNo">297</span>    if (numReferenceOutcomes != numPredictedOutcomes) {<a name="line.297"></a>
<span class="sourceLineNo">298</span>      throw new IllegalStateException(<a name="line.298"></a>
<span class="sourceLineNo">299</span>          String.format(<a name="line.299"></a>
<span class="sourceLineNo">300</span>              "Expected number equal number of references outcomes and predicted outcomes.  Had reference outcomes=%d, predicted outcomes=%d",<a name="line.300"></a>
<span class="sourceLineNo">301</span>              numReferenceOutcomes,<a name="line.301"></a>
<span class="sourceLineNo">302</span>              numPredictedOutcomes,<a name="line.302"></a>
<span class="sourceLineNo">303</span>              this.countPredictedOutcomes()));<a name="line.303"></a>
<span class="sourceLineNo">304</span>    }<a name="line.304"></a>
<span class="sourceLineNo">305</span>    int totalFalsePositives = 0;<a name="line.305"></a>
<span class="sourceLineNo">306</span>    for (OUTCOME_TYPE positiveOutcome : positiveOutcomes) {<a name="line.306"></a>
<span class="sourceLineNo">307</span>      totalFalsePositives += this.countPredictedOutcomes(positiveOutcome)<a name="line.307"></a>
<span class="sourceLineNo">308</span>          - this.countCorrectOutcomes(positiveOutcome);<a name="line.308"></a>
<span class="sourceLineNo">309</span>    }<a name="line.309"></a>
<span class="sourceLineNo">310</span><a name="line.310"></a>
<span class="sourceLineNo">311</span>    return totalFalsePositives;<a name="line.311"></a>
<span class="sourceLineNo">312</span>  }<a name="line.312"></a>
<span class="sourceLineNo">313</span><a name="line.313"></a>
<span class="sourceLineNo">314</span>  public int countTrueNegatives(@SuppressWarnings("unchecked") OUTCOME_TYPE... positiveOutcomes) {<a name="line.314"></a>
<span class="sourceLineNo">315</span>    int numReferenceOutcomes = this.countReferenceOutcomes();<a name="line.315"></a>
<span class="sourceLineNo">316</span>    int numPredictedOutcomes = this.countPredictedOutcomes();<a name="line.316"></a>
<span class="sourceLineNo">317</span>    if (numReferenceOutcomes != numPredictedOutcomes) {<a name="line.317"></a>
<span class="sourceLineNo">318</span>      throw new IllegalStateException(<a name="line.318"></a>
<span class="sourceLineNo">319</span>          String.format(<a name="line.319"></a>
<span class="sourceLineNo">320</span>              "Expected number equal number of references outcomes and predicted outcomes.  Had reference outcomes=%d, predicted outcomes=%d",<a name="line.320"></a>
<span class="sourceLineNo">321</span>              numReferenceOutcomes,<a name="line.321"></a>
<span class="sourceLineNo">322</span>              numPredictedOutcomes,<a name="line.322"></a>
<span class="sourceLineNo">323</span>              this.countPredictedOutcomes()));<a name="line.323"></a>
<span class="sourceLineNo">324</span>    }<a name="line.324"></a>
<span class="sourceLineNo">325</span>    int totalTrueNegatives = this.countCorrectOutcomes();<a name="line.325"></a>
<span class="sourceLineNo">326</span><a name="line.326"></a>
<span class="sourceLineNo">327</span>    for (OUTCOME_TYPE positiveOutcome : positiveOutcomes) {<a name="line.327"></a>
<span class="sourceLineNo">328</span>      totalTrueNegatives -= this.countCorrectOutcomes(positiveOutcome);<a name="line.328"></a>
<span class="sourceLineNo">329</span>    }<a name="line.329"></a>
<span class="sourceLineNo">330</span><a name="line.330"></a>
<span class="sourceLineNo">331</span>    return totalTrueNegatives;<a name="line.331"></a>
<span class="sourceLineNo">332</span><a name="line.332"></a>
<span class="sourceLineNo">333</span>  }<a name="line.333"></a>
<span class="sourceLineNo">334</span><a name="line.334"></a>
<span class="sourceLineNo">335</span>  public int countTruePositives(@SuppressWarnings("unchecked") OUTCOME_TYPE... positiveOutcomes) {<a name="line.335"></a>
<span class="sourceLineNo">336</span>    int numReferenceOutcomes = this.countReferenceOutcomes();<a name="line.336"></a>
<span class="sourceLineNo">337</span>    int numPredictedOutcomes = this.countPredictedOutcomes();<a name="line.337"></a>
<span class="sourceLineNo">338</span>    if (numReferenceOutcomes != numPredictedOutcomes) {<a name="line.338"></a>
<span class="sourceLineNo">339</span>      throw new IllegalStateException(<a name="line.339"></a>
<span class="sourceLineNo">340</span>          String.format(<a name="line.340"></a>
<span class="sourceLineNo">341</span>              "Expected number equal number of references outcomes and predicted outcomes.  Had reference outcomes=%d, predicted outcomes=%d",<a name="line.341"></a>
<span class="sourceLineNo">342</span>              numReferenceOutcomes,<a name="line.342"></a>
<span class="sourceLineNo">343</span>              numPredictedOutcomes,<a name="line.343"></a>
<span class="sourceLineNo">344</span>              this.countPredictedOutcomes()));<a name="line.344"></a>
<span class="sourceLineNo">345</span>    }<a name="line.345"></a>
<span class="sourceLineNo">346</span><a name="line.346"></a>
<span class="sourceLineNo">347</span>    int totalTruePositives = 0;<a name="line.347"></a>
<span class="sourceLineNo">348</span>    for (OUTCOME_TYPE positiveOutcome : positiveOutcomes) {<a name="line.348"></a>
<span class="sourceLineNo">349</span>      totalTruePositives += this.countCorrectOutcomes(positiveOutcome);<a name="line.349"></a>
<span class="sourceLineNo">350</span>    }<a name="line.350"></a>
<span class="sourceLineNo">351</span>    return totalTruePositives;<a name="line.351"></a>
<span class="sourceLineNo">352</span>  }<a name="line.352"></a>
<span class="sourceLineNo">353</span><a name="line.353"></a>
<span class="sourceLineNo">354</span>  /**<a name="line.354"></a>
<span class="sourceLineNo">355</span>   * Returns the {@link ConfusionMatrix} tabulating reference outcomes matched to predicted<a name="line.355"></a>
<span class="sourceLineNo">356</span>   * outcomes.<a name="line.356"></a>
<span class="sourceLineNo">357</span>   * <a name="line.357"></a>
<span class="sourceLineNo">358</span>   * @return The confusion matrix.<a name="line.358"></a>
<span class="sourceLineNo">359</span>   */<a name="line.359"></a>
<span class="sourceLineNo">360</span>  public ConfusionMatrix&lt;OUTCOME_TYPE&gt; confusions() {<a name="line.360"></a>
<span class="sourceLineNo">361</span>    return this.confusionMatrix;<a name="line.361"></a>
<span class="sourceLineNo">362</span>  }<a name="line.362"></a>
<span class="sourceLineNo">363</span><a name="line.363"></a>
<span class="sourceLineNo">364</span>  public double precision() {<a name="line.364"></a>
<span class="sourceLineNo">365</span>    int nSystem = this.countPredictedOutcomes();<a name="line.365"></a>
<span class="sourceLineNo">366</span>    return nSystem == 0 ? 1.0 : ((double) this.countCorrectOutcomes()) / nSystem;<a name="line.366"></a>
<span class="sourceLineNo">367</span>  }<a name="line.367"></a>
<span class="sourceLineNo">368</span><a name="line.368"></a>
<span class="sourceLineNo">369</span>  public double precision(OUTCOME_TYPE outcome) {<a name="line.369"></a>
<span class="sourceLineNo">370</span>    int nSystem = this.countPredictedOutcomes(outcome);<a name="line.370"></a>
<span class="sourceLineNo">371</span>    return nSystem == 0 ? 1.0 : ((double) this.countCorrectOutcomes(outcome)) / nSystem;<a name="line.371"></a>
<span class="sourceLineNo">372</span>  }<a name="line.372"></a>
<span class="sourceLineNo">373</span><a name="line.373"></a>
<span class="sourceLineNo">374</span>  public double recall() {<a name="line.374"></a>
<span class="sourceLineNo">375</span>    int nGold = this.countReferenceOutcomes();<a name="line.375"></a>
<span class="sourceLineNo">376</span>    return nGold == 0 ? 1.0 : ((double) this.countCorrectOutcomes()) / nGold;<a name="line.376"></a>
<span class="sourceLineNo">377</span>  }<a name="line.377"></a>
<span class="sourceLineNo">378</span><a name="line.378"></a>
<span class="sourceLineNo">379</span>  public double recall(OUTCOME_TYPE outcome) {<a name="line.379"></a>
<span class="sourceLineNo">380</span>    int nGold = this.countReferenceOutcomes(outcome);<a name="line.380"></a>
<span class="sourceLineNo">381</span>    return nGold == 0 ? 1.0 : ((double) this.countCorrectOutcomes(outcome)) / nGold;<a name="line.381"></a>
<span class="sourceLineNo">382</span>  }<a name="line.382"></a>
<span class="sourceLineNo">383</span><a name="line.383"></a>
<span class="sourceLineNo">384</span>  public double f(double beta) {<a name="line.384"></a>
<span class="sourceLineNo">385</span>    double p = this.precision();<a name="line.385"></a>
<span class="sourceLineNo">386</span>    double r = this.recall();<a name="line.386"></a>
<span class="sourceLineNo">387</span>    double num = (1 + beta * beta) * p * r;<a name="line.387"></a>
<span class="sourceLineNo">388</span>    double den = (beta * beta * p) + r;<a name="line.388"></a>
<span class="sourceLineNo">389</span>    return den == 0.0 ? 0.0 : num / den;<a name="line.389"></a>
<span class="sourceLineNo">390</span>  }<a name="line.390"></a>
<span class="sourceLineNo">391</span><a name="line.391"></a>
<span class="sourceLineNo">392</span>  public double f(double beta, OUTCOME_TYPE outcome) {<a name="line.392"></a>
<span class="sourceLineNo">393</span>    double p = this.precision(outcome);<a name="line.393"></a>
<span class="sourceLineNo">394</span>    double r = this.recall(outcome);<a name="line.394"></a>
<span class="sourceLineNo">395</span>    double num = (1 + beta * beta) * p * r;<a name="line.395"></a>
<span class="sourceLineNo">396</span>    double den = (beta * beta * p) + r;<a name="line.396"></a>
<span class="sourceLineNo">397</span>    return den == 0.0 ? 0.0 : num / den;<a name="line.397"></a>
<span class="sourceLineNo">398</span>  }<a name="line.398"></a>
<span class="sourceLineNo">399</span><a name="line.399"></a>
<span class="sourceLineNo">400</span>  public double f1() {<a name="line.400"></a>
<span class="sourceLineNo">401</span>    return this.f(1.0);<a name="line.401"></a>
<span class="sourceLineNo">402</span>  }<a name="line.402"></a>
<span class="sourceLineNo">403</span><a name="line.403"></a>
<span class="sourceLineNo">404</span>  public double f1(OUTCOME_TYPE outcome) {<a name="line.404"></a>
<span class="sourceLineNo">405</span>    return f(1.0, outcome);<a name="line.405"></a>
<span class="sourceLineNo">406</span>  }<a name="line.406"></a>
<span class="sourceLineNo">407</span><a name="line.407"></a>
<span class="sourceLineNo">408</span>  @Override<a name="line.408"></a>
<span class="sourceLineNo">409</span>  public String toString() {<a name="line.409"></a>
<span class="sourceLineNo">410</span>    StringBuilder result = new StringBuilder();<a name="line.410"></a>
<span class="sourceLineNo">411</span>    result.append("P\tR\tF1\t#gold\t#system\t#correct\n");<a name="line.411"></a>
<span class="sourceLineNo">412</span>    result.append(String.format(<a name="line.412"></a>
<span class="sourceLineNo">413</span>        "%.3f\t%.3f\t%.3f\t%d\t%d\t%d\tOVERALL\n",<a name="line.413"></a>
<span class="sourceLineNo">414</span>        this.precision(),<a name="line.414"></a>
<span class="sourceLineNo">415</span>        this.recall(),<a name="line.415"></a>
<span class="sourceLineNo">416</span>        this.f1(),<a name="line.416"></a>
<span class="sourceLineNo">417</span>        this.referenceOutcomes.size(),<a name="line.417"></a>
<span class="sourceLineNo">418</span>        this.predictedOutcomes.size(),<a name="line.418"></a>
<span class="sourceLineNo">419</span>        this.correctOutcomes.size()));<a name="line.419"></a>
<span class="sourceLineNo">420</span>    List&lt;OUTCOME_TYPE&gt; outcomes = new ArrayList&lt;OUTCOME_TYPE&gt;(this.referenceOutcomes.elementSet());<a name="line.420"></a>
<span class="sourceLineNo">421</span>    if (outcomes.size() &gt; 1) {<a name="line.421"></a>
<span class="sourceLineNo">422</span>      Collections.sort(outcomes);<a name="line.422"></a>
<span class="sourceLineNo">423</span>      for (OUTCOME_TYPE outcome : outcomes) {<a name="line.423"></a>
<span class="sourceLineNo">424</span>        result.append(String.format(<a name="line.424"></a>
<span class="sourceLineNo">425</span>            "%.3f\t%.3f\t%.3f\t%d\t%d\t%d\t%s\n",<a name="line.425"></a>
<span class="sourceLineNo">426</span>            this.precision(outcome),<a name="line.426"></a>
<span class="sourceLineNo">427</span>            this.recall(outcome),<a name="line.427"></a>
<span class="sourceLineNo">428</span>            this.f1(outcome),<a name="line.428"></a>
<span class="sourceLineNo">429</span>            this.referenceOutcomes.count(outcome),<a name="line.429"></a>
<span class="sourceLineNo">430</span>            this.predictedOutcomes.count(outcome),<a name="line.430"></a>
<span class="sourceLineNo">431</span>            this.correctOutcomes.count(outcome),<a name="line.431"></a>
<span class="sourceLineNo">432</span>            outcome));<a name="line.432"></a>
<span class="sourceLineNo">433</span>      }<a name="line.433"></a>
<span class="sourceLineNo">434</span>    }<a name="line.434"></a>
<span class="sourceLineNo">435</span>    return result.toString();<a name="line.435"></a>
<span class="sourceLineNo">436</span>  }<a name="line.436"></a>
<span class="sourceLineNo">437</span><a name="line.437"></a>
<span class="sourceLineNo">438</span>  private static class Span {<a name="line.438"></a>
<span class="sourceLineNo">439</span><a name="line.439"></a>
<span class="sourceLineNo">440</span>    public int end;<a name="line.440"></a>
<span class="sourceLineNo">441</span><a name="line.441"></a>
<span class="sourceLineNo">442</span>    public int begin;<a name="line.442"></a>
<span class="sourceLineNo">443</span><a name="line.443"></a>
<span class="sourceLineNo">444</span>    public Span(Annotation annotation) {<a name="line.444"></a>
<span class="sourceLineNo">445</span>      this.begin = annotation.getBegin();<a name="line.445"></a>
<span class="sourceLineNo">446</span>      this.end = annotation.getEnd();<a name="line.446"></a>
<span class="sourceLineNo">447</span>    }<a name="line.447"></a>
<span class="sourceLineNo">448</span><a name="line.448"></a>
<span class="sourceLineNo">449</span>    @Override<a name="line.449"></a>
<span class="sourceLineNo">450</span>    public int hashCode() {<a name="line.450"></a>
<span class="sourceLineNo">451</span>      return Objects.hashCode(this.begin, this.end);<a name="line.451"></a>
<span class="sourceLineNo">452</span>    }<a name="line.452"></a>
<span class="sourceLineNo">453</span><a name="line.453"></a>
<span class="sourceLineNo">454</span>    @Override<a name="line.454"></a>
<span class="sourceLineNo">455</span>    public boolean equals(Object obj) {<a name="line.455"></a>
<span class="sourceLineNo">456</span>      if (!this.getClass().equals(obj.getClass())) {<a name="line.456"></a>
<span class="sourceLineNo">457</span>        return false;<a name="line.457"></a>
<span class="sourceLineNo">458</span>      }<a name="line.458"></a>
<span class="sourceLineNo">459</span>      Span that = (Span) obj;<a name="line.459"></a>
<span class="sourceLineNo">460</span>      return this.begin == that.begin &amp;&amp; this.end == that.end;<a name="line.460"></a>
<span class="sourceLineNo">461</span>    }<a name="line.461"></a>
<span class="sourceLineNo">462</span><a name="line.462"></a>
<span class="sourceLineNo">463</span>    @Override<a name="line.463"></a>
<span class="sourceLineNo">464</span>    public String toString() {<a name="line.464"></a>
<span class="sourceLineNo">465</span>      ToStringHelper helper = Objects.toStringHelper(this);<a name="line.465"></a>
<span class="sourceLineNo">466</span>      helper.add("begin", this.begin);<a name="line.466"></a>
<span class="sourceLineNo">467</span>      helper.add("end", this.end);<a name="line.467"></a>
<span class="sourceLineNo">468</span>      return helper.toString();<a name="line.468"></a>
<span class="sourceLineNo">469</span>    }<a name="line.469"></a>
<span class="sourceLineNo">470</span>  }<a name="line.470"></a>
<span class="sourceLineNo">471</span>}<a name="line.471"></a>




























































</pre>
</div>
</body>
</html>
