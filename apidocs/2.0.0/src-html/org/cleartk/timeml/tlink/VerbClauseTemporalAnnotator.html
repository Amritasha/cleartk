<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/** <a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2007-2008, Regents of the University of Colorado <a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved.<a name="line.3"></a>
<span class="sourceLineNo">004</span> * <a name="line.4"></a>
<span class="sourceLineNo">005</span> * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<span class="sourceLineNo">006</span> * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<span class="sourceLineNo">007</span> * <a name="line.7"></a>
<span class="sourceLineNo">008</span> * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<span class="sourceLineNo">009</span> * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<span class="sourceLineNo">010</span> * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<span class="sourceLineNo">011</span> * <a name="line.11"></a>
<span class="sourceLineNo">012</span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<span class="sourceLineNo">013</span> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<span class="sourceLineNo">014</span> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<span class="sourceLineNo">015</span> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<span class="sourceLineNo">016</span> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<span class="sourceLineNo">017</span> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<span class="sourceLineNo">018</span> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<span class="sourceLineNo">019</span> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<span class="sourceLineNo">020</span> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<span class="sourceLineNo">021</span> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<span class="sourceLineNo">022</span> * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<span class="sourceLineNo">023</span> */<a name="line.23"></a>
<span class="sourceLineNo">024</span>package org.cleartk.timeml.tlink;<a name="line.24"></a>
<span class="sourceLineNo">025</span><a name="line.25"></a>
<span class="sourceLineNo">026</span>import java.util.ArrayList;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import java.util.Arrays;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import java.util.HashMap;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import java.util.HashSet;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import java.util.List;<a name="line.30"></a>
<span class="sourceLineNo">031</span>import java.util.Map;<a name="line.31"></a>
<span class="sourceLineNo">032</span>import java.util.Set;<a name="line.32"></a>
<span class="sourceLineNo">033</span><a name="line.33"></a>
<span class="sourceLineNo">034</span>import org.apache.uima.analysis_engine.AnalysisEngineDescription;<a name="line.34"></a>
<span class="sourceLineNo">035</span>import org.apache.uima.analysis_engine.AnalysisEngineProcessException;<a name="line.35"></a>
<span class="sourceLineNo">036</span>import org.apache.uima.jcas.JCas;<a name="line.36"></a>
<span class="sourceLineNo">037</span>import org.apache.uima.jcas.tcas.Annotation;<a name="line.37"></a>
<span class="sourceLineNo">038</span>import org.apache.uima.resource.ResourceInitializationException;<a name="line.38"></a>
<span class="sourceLineNo">039</span>import org.apache.uima.util.Level;<a name="line.39"></a>
<span class="sourceLineNo">040</span>import org.cleartk.feature.syntax.TargetPathExtractor;<a name="line.40"></a>
<span class="sourceLineNo">041</span>import org.cleartk.feature.token.TokenTextForSelectedPosExtractor;<a name="line.41"></a>
<span class="sourceLineNo">042</span>import org.cleartk.ml.CleartkAnnotator;<a name="line.42"></a>
<span class="sourceLineNo">043</span>import org.cleartk.ml.Instance;<a name="line.43"></a>
<span class="sourceLineNo">044</span>import org.cleartk.ml.feature.extractor.CleartkExtractor;<a name="line.44"></a>
<span class="sourceLineNo">045</span>import org.cleartk.ml.feature.extractor.CoveredTextExtractor;<a name="line.45"></a>
<span class="sourceLineNo">046</span>import org.cleartk.ml.feature.extractor.FeatureExtractor1;<a name="line.46"></a>
<span class="sourceLineNo">047</span>import org.cleartk.ml.feature.extractor.NamingExtractor1;<a name="line.47"></a>
<span class="sourceLineNo">048</span>import org.cleartk.ml.feature.extractor.TypePathExtractor;<a name="line.48"></a>
<span class="sourceLineNo">049</span>import org.cleartk.ml.feature.extractor.CleartkExtractor.Bag;<a name="line.49"></a>
<span class="sourceLineNo">050</span>import org.cleartk.ml.feature.extractor.CleartkExtractor.Covered;<a name="line.50"></a>
<span class="sourceLineNo">051</span>import org.cleartk.ml.feature.extractor.CleartkExtractor.Preceding;<a name="line.51"></a>
<span class="sourceLineNo">052</span>import org.cleartk.ml.liblinear.LibLinearStringOutcomeDataWriter;<a name="line.52"></a>
<span class="sourceLineNo">053</span>import org.cleartk.syntax.constituent.type.TopTreebankNode;<a name="line.53"></a>
<span class="sourceLineNo">054</span>import org.cleartk.syntax.constituent.type.TreebankNode;<a name="line.54"></a>
<span class="sourceLineNo">055</span>import org.cleartk.timeml.type.Anchor;<a name="line.55"></a>
<span class="sourceLineNo">056</span>import org.cleartk.timeml.type.Event;<a name="line.56"></a>
<span class="sourceLineNo">057</span>import org.cleartk.timeml.type.TemporalLink;<a name="line.57"></a>
<span class="sourceLineNo">058</span>import org.cleartk.timeml.util.CleartkInternalModelFactory;<a name="line.58"></a>
<span class="sourceLineNo">059</span>import org.cleartk.token.type.Sentence;<a name="line.59"></a>
<span class="sourceLineNo">060</span>import org.cleartk.token.type.Token;<a name="line.60"></a>
<span class="sourceLineNo">061</span>import org.cleartk.util.AnnotationUtil;<a name="line.61"></a>
<span class="sourceLineNo">062</span>import org.apache.uima.fit.descriptor.ConfigurationParameter;<a name="line.62"></a>
<span class="sourceLineNo">063</span>import org.apache.uima.fit.descriptor.TypeCapability;<a name="line.63"></a>
<span class="sourceLineNo">064</span>import org.apache.uima.fit.factory.AnalysisEngineFactory;<a name="line.64"></a>
<span class="sourceLineNo">065</span>import org.apache.uima.fit.util.JCasUtil;<a name="line.65"></a>
<span class="sourceLineNo">066</span><a name="line.66"></a>
<span class="sourceLineNo">067</span>import com.google.common.collect.Lists;<a name="line.67"></a>
<span class="sourceLineNo">068</span><a name="line.68"></a>
<span class="sourceLineNo">069</span>/**<a name="line.69"></a>
<span class="sourceLineNo">070</span> * &lt;br&gt;<a name="line.70"></a>
<span class="sourceLineNo">071</span> * Copyright (c) 2007-2008, Regents of the University of Colorado &lt;br&gt;<a name="line.71"></a>
<span class="sourceLineNo">072</span> * All rights reserved.<a name="line.72"></a>
<span class="sourceLineNo">073</span> * <a name="line.73"></a>
<span class="sourceLineNo">074</span> * <a name="line.74"></a>
<span class="sourceLineNo">075</span> * <a name="line.75"></a>
<span class="sourceLineNo">076</span> * @author Steven Bethard<a name="line.76"></a>
<span class="sourceLineNo">077</span> */<a name="line.77"></a>
<span class="sourceLineNo">078</span>@TypeCapability(<a name="line.78"></a>
<span class="sourceLineNo">079</span>    outputs = { "org.cleartk.timeml.type.TemporalLink", "org.cleartk.timeml.type.Event" })<a name="line.79"></a>
<span class="sourceLineNo">080</span>public class VerbClauseTemporalAnnotator extends CleartkAnnotator&lt;String&gt; {<a name="line.80"></a>
<span class="sourceLineNo">081</span><a name="line.81"></a>
<span class="sourceLineNo">082</span>  public static final CleartkInternalModelFactory FACTORY = new CleartkInternalModelFactory() {<a name="line.82"></a>
<span class="sourceLineNo">083</span>    @Override<a name="line.83"></a>
<span class="sourceLineNo">084</span>    public Class&lt;?&gt; getAnnotatorClass() {<a name="line.84"></a>
<span class="sourceLineNo">085</span>      return VerbClauseTemporalAnnotator.class;<a name="line.85"></a>
<span class="sourceLineNo">086</span>    }<a name="line.86"></a>
<span class="sourceLineNo">087</span><a name="line.87"></a>
<span class="sourceLineNo">088</span>    @Override<a name="line.88"></a>
<span class="sourceLineNo">089</span>    public Class&lt;?&gt; getDataWriterClass() {<a name="line.89"></a>
<span class="sourceLineNo">090</span>      return LibLinearStringOutcomeDataWriter.class;<a name="line.90"></a>
<span class="sourceLineNo">091</span>    }<a name="line.91"></a>
<span class="sourceLineNo">092</span><a name="line.92"></a>
<span class="sourceLineNo">093</span>    @Override<a name="line.93"></a>
<span class="sourceLineNo">094</span>    public AnalysisEngineDescription getBaseDescription() throws ResourceInitializationException {<a name="line.94"></a>
<span class="sourceLineNo">095</span>      return AnalysisEngineFactory.createEngineDescription(VerbClauseTemporalAnnotator.class);<a name="line.95"></a>
<span class="sourceLineNo">096</span>    }<a name="line.96"></a>
<span class="sourceLineNo">097</span>  };<a name="line.97"></a>
<span class="sourceLineNo">098</span><a name="line.98"></a>
<span class="sourceLineNo">099</span>  private static final Map&lt;String, String[]&gt; headMap = new HashMap&lt;String, String[]&gt;();<a name="line.99"></a>
<span class="sourceLineNo">100</span>  static {<a name="line.100"></a>
<span class="sourceLineNo">101</span>    headMap.put("S", "VP S SBAR ADJP".split(" "));<a name="line.101"></a>
<span class="sourceLineNo">102</span>    headMap.put("SBAR", "VP S SBAR ADJP".split(" "));<a name="line.102"></a>
<span class="sourceLineNo">103</span>    headMap.put("VP", ("VP VB VBZ VBP VBG VBN VBD JJ JJR JJS "<a name="line.103"></a>
<span class="sourceLineNo">104</span>        + "NNS NN PRP NNPS NNP ADJP NP S SBAR").split(" "));<a name="line.104"></a>
<span class="sourceLineNo">105</span>    headMap.put("ADJP", "ADJP VB VBZ VBP VBG VBN VBD JJ JJR JJS".split(" "));<a name="line.105"></a>
<span class="sourceLineNo">106</span>    headMap.put("NP", "NP NNS NN PRP NNPS NNP QP ADJP".split(" "));<a name="line.106"></a>
<span class="sourceLineNo">107</span>    headMap.put("QP", "NP NNS NN PRP NNPS NNP QP ADJP".split(" "));<a name="line.107"></a>
<span class="sourceLineNo">108</span>  }<a name="line.108"></a>
<span class="sourceLineNo">109</span><a name="line.109"></a>
<span class="sourceLineNo">110</span>  private static final Set&lt;String&gt; stopWords = new HashSet&lt;String&gt;(<a name="line.110"></a>
<span class="sourceLineNo">111</span>      Arrays.asList("be been is 's am are was were has had have".split(" ")));<a name="line.111"></a>
<span class="sourceLineNo">112</span><a name="line.112"></a>
<span class="sourceLineNo">113</span>  private List&lt;FeatureExtractor1&lt;Token&gt;&gt; sourceFeatureExtractors;<a name="line.113"></a>
<span class="sourceLineNo">114</span><a name="line.114"></a>
<span class="sourceLineNo">115</span>  private List&lt;FeatureExtractor1&lt;Token&gt;&gt; targetFeatureExtractors;<a name="line.115"></a>
<span class="sourceLineNo">116</span><a name="line.116"></a>
<span class="sourceLineNo">117</span>  private List&lt;FeatureExtractor1&lt;Annotation&gt;&gt; betweenAnchorsFeatureExtractors;<a name="line.117"></a>
<span class="sourceLineNo">118</span><a name="line.118"></a>
<span class="sourceLineNo">119</span>  private TargetPathExtractor pathExtractor;<a name="line.119"></a>
<span class="sourceLineNo">120</span><a name="line.120"></a>
<span class="sourceLineNo">121</span>  private int eventID;<a name="line.121"></a>
<span class="sourceLineNo">122</span><a name="line.122"></a>
<span class="sourceLineNo">123</span>  @ConfigurationParameter(<a name="line.123"></a>
<span class="sourceLineNo">124</span>      name = PARAM_CREATE_EVENTS,<a name="line.124"></a>
<span class="sourceLineNo">125</span>      defaultValue = "false", description = "Create events for all verbs in "<a name="line.125"></a>
<span class="sourceLineNo">126</span>      + "verb-clause relations (using existing events if present, but adding new ones "<a name="line.126"></a>
<span class="sourceLineNo">127</span>      + "wherever they are not present).")<a name="line.127"></a>
<span class="sourceLineNo">128</span>  private boolean createEvents;<a name="line.128"></a>
<span class="sourceLineNo">129</span><a name="line.129"></a>
<span class="sourceLineNo">130</span>  public static final String PARAM_CREATE_EVENTS = "createEvents";<a name="line.130"></a>
<span class="sourceLineNo">131</span>  <a name="line.131"></a>
<span class="sourceLineNo">132</span>  public VerbClauseTemporalAnnotator() {<a name="line.132"></a>
<span class="sourceLineNo">133</span>    this.eventID = 1;<a name="line.133"></a>
<span class="sourceLineNo">134</span><a name="line.134"></a>
<span class="sourceLineNo">135</span>    FeatureExtractor1&lt;Token&gt; precedingAuxiliaries = new CleartkExtractor&lt;Token, Token&gt;(<a name="line.135"></a>
<span class="sourceLineNo">136</span>        Token.class,<a name="line.136"></a>
<span class="sourceLineNo">137</span>        new TokenTextForSelectedPosExtractor("MD", "TO", "IN", "VB", "RB"),<a name="line.137"></a>
<span class="sourceLineNo">138</span>        new Preceding(3));<a name="line.138"></a>
<span class="sourceLineNo">139</span>    FeatureExtractor1&lt;Token&gt; tokenStemExtractor = new TypePathExtractor&lt;Token&gt;(Token.class, "stem");<a name="line.139"></a>
<span class="sourceLineNo">140</span>    FeatureExtractor1&lt;Token&gt; tokenPOSExtractor = new TypePathExtractor&lt;Token&gt;(Token.class, "pos");<a name="line.140"></a>
<span class="sourceLineNo">141</span><a name="line.141"></a>
<span class="sourceLineNo">142</span>    this.sourceFeatureExtractors = Lists.newArrayList();<a name="line.142"></a>
<span class="sourceLineNo">143</span>    this.sourceFeatureExtractors.add(new NamingExtractor1&lt;Token&gt;("Source", new CoveredTextExtractor&lt;Token&gt;()));<a name="line.143"></a>
<span class="sourceLineNo">144</span>    this.sourceFeatureExtractors.add(new NamingExtractor1&lt;Token&gt;("Source", tokenPOSExtractor));<a name="line.144"></a>
<span class="sourceLineNo">145</span>    this.sourceFeatureExtractors.add(new NamingExtractor1&lt;Token&gt;("Source", tokenStemExtractor));<a name="line.145"></a>
<span class="sourceLineNo">146</span>    this.sourceFeatureExtractors.add(new NamingExtractor1&lt;Token&gt;("Source", precedingAuxiliaries));<a name="line.146"></a>
<span class="sourceLineNo">147</span><a name="line.147"></a>
<span class="sourceLineNo">148</span>    this.targetFeatureExtractors = Lists.newArrayList();<a name="line.148"></a>
<span class="sourceLineNo">149</span>    this.targetFeatureExtractors.add(new NamingExtractor1&lt;Token&gt;("Target", new CoveredTextExtractor&lt;Token&gt;()));<a name="line.149"></a>
<span class="sourceLineNo">150</span>    this.targetFeatureExtractors.add(new NamingExtractor1&lt;Token&gt;("Target", tokenPOSExtractor));<a name="line.150"></a>
<span class="sourceLineNo">151</span>    this.targetFeatureExtractors.add(new NamingExtractor1&lt;Token&gt;("Target", tokenStemExtractor));<a name="line.151"></a>
<span class="sourceLineNo">152</span>    this.targetFeatureExtractors.add(new NamingExtractor1&lt;Token&gt;("Target", precedingAuxiliaries));<a name="line.152"></a>
<span class="sourceLineNo">153</span><a name="line.153"></a>
<span class="sourceLineNo">154</span>    this.betweenAnchorsFeatureExtractors = new ArrayList&lt;FeatureExtractor1&lt;Annotation&gt;&gt;();<a name="line.154"></a>
<span class="sourceLineNo">155</span>    this.betweenAnchorsFeatureExtractors.add(new NamingExtractor1&lt;Annotation&gt;(<a name="line.155"></a>
<span class="sourceLineNo">156</span>        "WordsBetween",<a name="line.156"></a>
<span class="sourceLineNo">157</span>        new CleartkExtractor&lt;Annotation, Token&gt;(Token.class, new CoveredTextExtractor&lt;Token&gt;(), new Bag(new Covered()))));<a name="line.157"></a>
<span class="sourceLineNo">158</span>    this.pathExtractor = new TargetPathExtractor();<a name="line.158"></a>
<span class="sourceLineNo">159</span>  }<a name="line.159"></a>
<span class="sourceLineNo">160</span><a name="line.160"></a>
<span class="sourceLineNo">161</span>  public void process(JCas jCas) throws AnalysisEngineProcessException {<a name="line.161"></a>
<span class="sourceLineNo">162</span>    int docEnd = jCas.getDocumentText().length();<a name="line.162"></a>
<span class="sourceLineNo">163</span><a name="line.163"></a>
<span class="sourceLineNo">164</span>    // collect TLINKs if necessary<a name="line.164"></a>
<span class="sourceLineNo">165</span>    Map&lt;String, TemporalLink&gt; tlinks = null;<a name="line.165"></a>
<span class="sourceLineNo">166</span>    if (this.isTraining()) {<a name="line.166"></a>
<span class="sourceLineNo">167</span>      tlinks = this.getTemporalLinks(jCas);<a name="line.167"></a>
<span class="sourceLineNo">168</span>    }<a name="line.168"></a>
<span class="sourceLineNo">169</span><a name="line.169"></a>
<span class="sourceLineNo">170</span>    // look for verb-clause pairs in each sentence in the document<a name="line.170"></a>
<span class="sourceLineNo">171</span>    for (Sentence sentence : JCasUtil.select(jCas, Sentence.class)) {<a name="line.171"></a>
<span class="sourceLineNo">172</span>      TopTreebankNode tree = AnnotationUtil.selectFirstMatching(<a name="line.172"></a>
<span class="sourceLineNo">173</span>          jCas,<a name="line.173"></a>
<span class="sourceLineNo">174</span>          TopTreebankNode.class,<a name="line.174"></a>
<span class="sourceLineNo">175</span>          sentence);<a name="line.175"></a>
<span class="sourceLineNo">176</span>      if (tree == null) {<a name="line.176"></a>
<span class="sourceLineNo">177</span>        String fmt = "missing syntactic parse for sentence: %s";<a name="line.177"></a>
<span class="sourceLineNo">178</span>        String msg = String.format(fmt, sentence.getCoveredText());<a name="line.178"></a>
<span class="sourceLineNo">179</span>        this.getContext().getLogger().log(Level.WARNING, msg);<a name="line.179"></a>
<span class="sourceLineNo">180</span>        continue;<a name="line.180"></a>
<span class="sourceLineNo">181</span>      }<a name="line.181"></a>
<span class="sourceLineNo">182</span><a name="line.182"></a>
<span class="sourceLineNo">183</span>      // iterate over all verb-clause pairs<a name="line.183"></a>
<span class="sourceLineNo">184</span>      List&lt;TreebankNodeLink&gt; links = new ArrayList&lt;TreebankNodeLink&gt;();<a name="line.184"></a>
<span class="sourceLineNo">185</span>      this.collectVerbClausePairs(tree, links);<a name="line.185"></a>
<span class="sourceLineNo">186</span>      for (TreebankNodeLink link : links) {<a name="line.186"></a>
<span class="sourceLineNo">187</span><a name="line.187"></a>
<span class="sourceLineNo">188</span>        Token sourceToken = JCasUtil.selectCovered(jCas, Token.class, link.source).get(0);<a name="line.188"></a>
<span class="sourceLineNo">189</span>        Token targetToken = JCasUtil.selectCovered(jCas, Token.class, link.target).get(0);<a name="line.189"></a>
<span class="sourceLineNo">190</span>        int firstEnd = Math.min(sourceToken.getEnd(), targetToken.getEnd());<a name="line.190"></a>
<span class="sourceLineNo">191</span>        int lastBegin = Math.max(sourceToken.getBegin(), targetToken.getBegin());<a name="line.191"></a>
<span class="sourceLineNo">192</span><a name="line.192"></a>
<span class="sourceLineNo">193</span>        // create an instance and populate it with features<a name="line.193"></a>
<span class="sourceLineNo">194</span>        Instance&lt;String&gt; instance = new Instance&lt;String&gt;();<a name="line.194"></a>
<span class="sourceLineNo">195</span>        for (FeatureExtractor1&lt;Token&gt; extractor : this.sourceFeatureExtractors) {<a name="line.195"></a>
<span class="sourceLineNo">196</span>          instance.addAll(extractor.extract(jCas, sourceToken));<a name="line.196"></a>
<span class="sourceLineNo">197</span>        }<a name="line.197"></a>
<span class="sourceLineNo">198</span>        for (FeatureExtractor1&lt;Token&gt; extractor : this.targetFeatureExtractors) {<a name="line.198"></a>
<span class="sourceLineNo">199</span>          instance.addAll(extractor.extract(jCas, targetToken));<a name="line.199"></a>
<span class="sourceLineNo">200</span>        }<a name="line.200"></a>
<span class="sourceLineNo">201</span>        Annotation windowAnnotation = new Annotation(jCas, firstEnd, lastBegin);<a name="line.201"></a>
<span class="sourceLineNo">202</span>        for (FeatureExtractor1&lt;Annotation&gt; extractor : this.betweenAnchorsFeatureExtractors) {<a name="line.202"></a>
<span class="sourceLineNo">203</span>          instance.addAll(extractor.extract(jCas, windowAnnotation));<a name="line.203"></a>
<span class="sourceLineNo">204</span>        }<a name="line.204"></a>
<span class="sourceLineNo">205</span>        instance.addAll(this.pathExtractor.extract(jCas, link.source, link.target));<a name="line.205"></a>
<span class="sourceLineNo">206</span><a name="line.206"></a>
<span class="sourceLineNo">207</span>        // find source and target anchors if they're available<a name="line.207"></a>
<span class="sourceLineNo">208</span>        Anchor source = AnnotationUtil.selectFirstMatching(jCas, Anchor.class, link.source);<a name="line.208"></a>
<span class="sourceLineNo">209</span>        Anchor target = AnnotationUtil.selectFirstMatching(jCas, Anchor.class, link.target);<a name="line.209"></a>
<span class="sourceLineNo">210</span><a name="line.210"></a>
<span class="sourceLineNo">211</span>        // if we're building training data, get the relation type from a<a name="line.211"></a>
<span class="sourceLineNo">212</span>        // TLINK<a name="line.212"></a>
<span class="sourceLineNo">213</span>        if (this.isTraining()) {<a name="line.213"></a>
<span class="sourceLineNo">214</span>          if (source != null &amp;&amp; target != null) {<a name="line.214"></a>
<span class="sourceLineNo">215</span>            String key = String.format("%s:%s", source.getId(), target.getId());<a name="line.215"></a>
<span class="sourceLineNo">216</span>            TemporalLink tlink = tlinks.remove(key);<a name="line.216"></a>
<span class="sourceLineNo">217</span>            if (tlink != null) {<a name="line.217"></a>
<span class="sourceLineNo">218</span>              instance.setOutcome(tlink.getRelationType());<a name="line.218"></a>
<span class="sourceLineNo">219</span>              this.dataWriter.write(instance);<a name="line.219"></a>
<span class="sourceLineNo">220</span>            }<a name="line.220"></a>
<span class="sourceLineNo">221</span>          }<a name="line.221"></a>
<span class="sourceLineNo">222</span>        }<a name="line.222"></a>
<span class="sourceLineNo">223</span><a name="line.223"></a>
<span class="sourceLineNo">224</span>        // if we're classifying create new TLINKs from the<a name="line.224"></a>
<span class="sourceLineNo">225</span>        // classification outcomes<a name="line.225"></a>
<span class="sourceLineNo">226</span>        else {<a name="line.226"></a>
<span class="sourceLineNo">227</span>          source = this.getOrCreateEvent(jCas, source, link.source);<a name="line.227"></a>
<span class="sourceLineNo">228</span>          target = this.getOrCreateEvent(jCas, target, link.target);<a name="line.228"></a>
<span class="sourceLineNo">229</span>          // only create TLINKs for events that exist (or were created, if requested)<a name="line.229"></a>
<span class="sourceLineNo">230</span>          if (source != null &amp;&amp; target != null) {<a name="line.230"></a>
<span class="sourceLineNo">231</span>            String relationType = this.classifier.classify(instance.getFeatures());<a name="line.231"></a>
<span class="sourceLineNo">232</span>            TemporalLink tlink = new TemporalLink(jCas, docEnd, docEnd);<a name="line.232"></a>
<span class="sourceLineNo">233</span>            tlink.setSource(source);<a name="line.233"></a>
<span class="sourceLineNo">234</span>            tlink.setTarget(target);<a name="line.234"></a>
<span class="sourceLineNo">235</span>            tlink.setRelationType(relationType);<a name="line.235"></a>
<span class="sourceLineNo">236</span>            tlink.addToIndexes();<a name="line.236"></a>
<span class="sourceLineNo">237</span>          }<a name="line.237"></a>
<span class="sourceLineNo">238</span>        }<a name="line.238"></a>
<span class="sourceLineNo">239</span>      }<a name="line.239"></a>
<span class="sourceLineNo">240</span>    }<a name="line.240"></a>
<span class="sourceLineNo">241</span>  }<a name="line.241"></a>
<span class="sourceLineNo">242</span><a name="line.242"></a>
<span class="sourceLineNo">243</span>  private Event getOrCreateEvent(JCas jCas, Anchor anchor, TreebankNode node) {<a name="line.243"></a>
<span class="sourceLineNo">244</span>    if (anchor != null &amp;&amp; anchor instanceof Event) {<a name="line.244"></a>
<span class="sourceLineNo">245</span>      return (Event) anchor;<a name="line.245"></a>
<span class="sourceLineNo">246</span>    } else if (this.createEvents) {<a name="line.246"></a>
<span class="sourceLineNo">247</span>      Event event = new Event(jCas, node.getBegin(), node.getEnd());<a name="line.247"></a>
<span class="sourceLineNo">248</span>      event.setId("e" + this.eventID);<a name="line.248"></a>
<span class="sourceLineNo">249</span>      this.eventID++;<a name="line.249"></a>
<span class="sourceLineNo">250</span>      event.addToIndexes();<a name="line.250"></a>
<span class="sourceLineNo">251</span>      return event;<a name="line.251"></a>
<span class="sourceLineNo">252</span>    } else {<a name="line.252"></a>
<span class="sourceLineNo">253</span>      return null;<a name="line.253"></a>
<span class="sourceLineNo">254</span>    }<a name="line.254"></a>
<span class="sourceLineNo">255</span>  }<a name="line.255"></a>
<span class="sourceLineNo">256</span><a name="line.256"></a>
<span class="sourceLineNo">257</span>  private Map&lt;String, TemporalLink&gt; getTemporalLinks(JCas jCas) {<a name="line.257"></a>
<span class="sourceLineNo">258</span>    Map&lt;String, TemporalLink&gt; tlinks = new HashMap&lt;String, TemporalLink&gt;();<a name="line.258"></a>
<span class="sourceLineNo">259</span>    for (TemporalLink tlink : JCasUtil.select(jCas, TemporalLink.class)) {<a name="line.259"></a>
<span class="sourceLineNo">260</span>      String sourceID = tlink.getSource().getId();<a name="line.260"></a>
<span class="sourceLineNo">261</span>      String targetID = tlink.getTarget().getId();<a name="line.261"></a>
<span class="sourceLineNo">262</span>      String key = String.format("%s:%s", sourceID, targetID);<a name="line.262"></a>
<span class="sourceLineNo">263</span>      tlinks.put(key, tlink);<a name="line.263"></a>
<span class="sourceLineNo">264</span>    }<a name="line.264"></a>
<span class="sourceLineNo">265</span>    return tlinks;<a name="line.265"></a>
<span class="sourceLineNo">266</span>  }<a name="line.266"></a>
<span class="sourceLineNo">267</span><a name="line.267"></a>
<span class="sourceLineNo">268</span>  private void collectVerbClausePairs(TreebankNode node, List&lt;TreebankNodeLink&gt; links) {<a name="line.268"></a>
<span class="sourceLineNo">269</span>    if (this.isVerbPhrase(node)) {<a name="line.269"></a>
<span class="sourceLineNo">270</span>      List&lt;TreebankNode&gt; sources = new ArrayList&lt;TreebankNode&gt;();<a name="line.270"></a>
<span class="sourceLineNo">271</span>      List&lt;TreebankNode&gt; targets = new ArrayList&lt;TreebankNode&gt;();<a name="line.271"></a>
<span class="sourceLineNo">272</span>      this.collectHeads(node, sources);<a name="line.272"></a>
<span class="sourceLineNo">273</span><a name="line.273"></a>
<span class="sourceLineNo">274</span>      // look for clauses in descendants<a name="line.274"></a>
<span class="sourceLineNo">275</span>      for (int i = 0; i &lt; node.getChildren().size(); i++) {<a name="line.275"></a>
<span class="sourceLineNo">276</span>        TreebankNode child = node.getChildren(i);<a name="line.276"></a>
<span class="sourceLineNo">277</span>        if (this.isClause(child)) {<a name="line.277"></a>
<span class="sourceLineNo">278</span><a name="line.278"></a>
<span class="sourceLineNo">279</span>          // pair the verb phrase heads with the clause heads<a name="line.279"></a>
<span class="sourceLineNo">280</span>          targets.clear();<a name="line.280"></a>
<span class="sourceLineNo">281</span>          this.collectHeads(child, targets);<a name="line.281"></a>
<span class="sourceLineNo">282</span>          for (TreebankNode source : sources) {<a name="line.282"></a>
<span class="sourceLineNo">283</span>            for (TreebankNode target : targets) {<a name="line.283"></a>
<span class="sourceLineNo">284</span><a name="line.284"></a>
<span class="sourceLineNo">285</span>              // skip pairs where the head of the VP is inside the<a name="line.285"></a>
<span class="sourceLineNo">286</span>              // clause<a name="line.286"></a>
<span class="sourceLineNo">287</span>              if (!this.contains(child, source)) {<a name="line.287"></a>
<span class="sourceLineNo">288</span>                links.add(new TreebankNodeLink(source, target));<a name="line.288"></a>
<span class="sourceLineNo">289</span>              }<a name="line.289"></a>
<span class="sourceLineNo">290</span>            }<a name="line.290"></a>
<span class="sourceLineNo">291</span>          }<a name="line.291"></a>
<span class="sourceLineNo">292</span>        }<a name="line.292"></a>
<span class="sourceLineNo">293</span>      }<a name="line.293"></a>
<span class="sourceLineNo">294</span>    }<a name="line.294"></a>
<span class="sourceLineNo">295</span>    // look for verb phrases in descendants<a name="line.295"></a>
<span class="sourceLineNo">296</span>    for (int i = 0; i &lt; node.getChildren().size(); i++) {<a name="line.296"></a>
<span class="sourceLineNo">297</span>      TreebankNode child = node.getChildren(i);<a name="line.297"></a>
<span class="sourceLineNo">298</span>      this.collectVerbClausePairs(child, links);<a name="line.298"></a>
<span class="sourceLineNo">299</span>    }<a name="line.299"></a>
<span class="sourceLineNo">300</span>  }<a name="line.300"></a>
<span class="sourceLineNo">301</span><a name="line.301"></a>
<span class="sourceLineNo">302</span>  private void collectHeads(TreebankNode node, List&lt;TreebankNode&gt; heads) {<a name="line.302"></a>
<span class="sourceLineNo">303</span>    if (node.getLeaf()) {<a name="line.303"></a>
<span class="sourceLineNo">304</span>      heads.add(node);<a name="line.304"></a>
<span class="sourceLineNo">305</span>    }<a name="line.305"></a>
<span class="sourceLineNo">306</span>    String[] headTypes = VerbClauseTemporalAnnotator.headMap.get(node.getNodeType());<a name="line.306"></a>
<span class="sourceLineNo">307</span>    if (headTypes != null) {<a name="line.307"></a>
<span class="sourceLineNo">308</span>      for (String headType : headTypes) {<a name="line.308"></a>
<span class="sourceLineNo">309</span>        boolean foundChildWithHeadType = false;<a name="line.309"></a>
<span class="sourceLineNo">310</span>        for (int i = 0; i &lt; node.getChildren().size(); i++) {<a name="line.310"></a>
<span class="sourceLineNo">311</span>          TreebankNode child = node.getChildren(i);<a name="line.311"></a>
<span class="sourceLineNo">312</span>          if (child.getNodeType().equals(headType)) {<a name="line.312"></a>
<span class="sourceLineNo">313</span>            String text = child.getCoveredText();<a name="line.313"></a>
<span class="sourceLineNo">314</span>            if (!VerbClauseTemporalAnnotator.stopWords.contains(text)) {<a name="line.314"></a>
<span class="sourceLineNo">315</span>              this.collectHeads(child, heads);<a name="line.315"></a>
<span class="sourceLineNo">316</span>              foundChildWithHeadType = true;<a name="line.316"></a>
<span class="sourceLineNo">317</span>            }<a name="line.317"></a>
<span class="sourceLineNo">318</span>          }<a name="line.318"></a>
<span class="sourceLineNo">319</span>        }<a name="line.319"></a>
<span class="sourceLineNo">320</span>        if (foundChildWithHeadType) {<a name="line.320"></a>
<span class="sourceLineNo">321</span>          break;<a name="line.321"></a>
<span class="sourceLineNo">322</span>        }<a name="line.322"></a>
<span class="sourceLineNo">323</span>      }<a name="line.323"></a>
<span class="sourceLineNo">324</span>    }<a name="line.324"></a>
<span class="sourceLineNo">325</span>  }<a name="line.325"></a>
<span class="sourceLineNo">326</span><a name="line.326"></a>
<span class="sourceLineNo">327</span>  private boolean contains(TreebankNode node, TreebankNode descendant) {<a name="line.327"></a>
<span class="sourceLineNo">328</span>    if (node == descendant) {<a name="line.328"></a>
<span class="sourceLineNo">329</span>      return true;<a name="line.329"></a>
<span class="sourceLineNo">330</span>    }<a name="line.330"></a>
<span class="sourceLineNo">331</span>    for (int i = 0; i &lt; node.getChildren().size(); i++) {<a name="line.331"></a>
<span class="sourceLineNo">332</span>      boolean result = this.contains(node.getChildren(i), descendant);<a name="line.332"></a>
<span class="sourceLineNo">333</span>      if (result) {<a name="line.333"></a>
<span class="sourceLineNo">334</span>        return true;<a name="line.334"></a>
<span class="sourceLineNo">335</span>      }<a name="line.335"></a>
<span class="sourceLineNo">336</span>    }<a name="line.336"></a>
<span class="sourceLineNo">337</span>    return false;<a name="line.337"></a>
<span class="sourceLineNo">338</span>  }<a name="line.338"></a>
<span class="sourceLineNo">339</span><a name="line.339"></a>
<span class="sourceLineNo">340</span>  private boolean isVerbPhrase(TreebankNode node) {<a name="line.340"></a>
<span class="sourceLineNo">341</span>    return node.getNodeType().startsWith("VP");<a name="line.341"></a>
<span class="sourceLineNo">342</span>  }<a name="line.342"></a>
<span class="sourceLineNo">343</span><a name="line.343"></a>
<span class="sourceLineNo">344</span>  private boolean isClause(TreebankNode node) {<a name="line.344"></a>
<span class="sourceLineNo">345</span>    return node.getNodeType().startsWith("S");<a name="line.345"></a>
<span class="sourceLineNo">346</span>  }<a name="line.346"></a>
<span class="sourceLineNo">347</span><a name="line.347"></a>
<span class="sourceLineNo">348</span>  private class TreebankNodeLink {<a name="line.348"></a>
<span class="sourceLineNo">349</span>    public TreebankNode source;<a name="line.349"></a>
<span class="sourceLineNo">350</span><a name="line.350"></a>
<span class="sourceLineNo">351</span>    public TreebankNode target;<a name="line.351"></a>
<span class="sourceLineNo">352</span><a name="line.352"></a>
<span class="sourceLineNo">353</span>    public TreebankNodeLink(TreebankNode source, TreebankNode target) {<a name="line.353"></a>
<span class="sourceLineNo">354</span>      this.source = source;<a name="line.354"></a>
<span class="sourceLineNo">355</span>      this.target = target;<a name="line.355"></a>
<span class="sourceLineNo">356</span>    }<a name="line.356"></a>
<span class="sourceLineNo">357</span>  }<a name="line.357"></a>
<span class="sourceLineNo">358</span><a name="line.358"></a>
<span class="sourceLineNo">359</span>}<a name="line.359"></a>




























































</pre>
</div>
</body>
</html>
