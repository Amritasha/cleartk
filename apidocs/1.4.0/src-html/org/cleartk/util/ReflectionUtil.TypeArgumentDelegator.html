<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/** <a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2007-2008, Regents of the University of Colorado <a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved.<a name="line.3"></a>
<span class="sourceLineNo">004</span> * <a name="line.4"></a>
<span class="sourceLineNo">005</span> * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<span class="sourceLineNo">006</span> * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<span class="sourceLineNo">007</span> * <a name="line.7"></a>
<span class="sourceLineNo">008</span> * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<span class="sourceLineNo">009</span> * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<span class="sourceLineNo">010</span> * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<span class="sourceLineNo">011</span> * <a name="line.11"></a>
<span class="sourceLineNo">012</span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<span class="sourceLineNo">013</span> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<span class="sourceLineNo">014</span> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<span class="sourceLineNo">015</span> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<span class="sourceLineNo">016</span> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<span class="sourceLineNo">017</span> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<span class="sourceLineNo">018</span> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<span class="sourceLineNo">019</span> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<span class="sourceLineNo">020</span> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<span class="sourceLineNo">021</span> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<span class="sourceLineNo">022</span> * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<span class="sourceLineNo">023</span> */<a name="line.23"></a>
<span class="sourceLineNo">024</span>package org.cleartk.util;<a name="line.24"></a>
<span class="sourceLineNo">025</span><a name="line.25"></a>
<span class="sourceLineNo">026</span>import java.lang.reflect.InvocationTargetException;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import java.lang.reflect.ParameterizedType;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import java.lang.reflect.Type;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import java.lang.reflect.TypeVariable;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import java.util.Map;<a name="line.30"></a>
<span class="sourceLineNo">031</span>import java.util.TreeMap;<a name="line.31"></a>
<span class="sourceLineNo">032</span><a name="line.32"></a>
<span class="sourceLineNo">033</span>import org.apache.uima.resource.ResourceInitializationException;<a name="line.33"></a>
<span class="sourceLineNo">034</span><a name="line.34"></a>
<span class="sourceLineNo">035</span>/**<a name="line.35"></a>
<span class="sourceLineNo">036</span> * &lt;br&gt;<a name="line.36"></a>
<span class="sourceLineNo">037</span> * Copyright (c) 2007-2008, Regents of the University of Colorado &lt;br&gt;<a name="line.37"></a>
<span class="sourceLineNo">038</span> * All rights reserved.<a name="line.38"></a>
<span class="sourceLineNo">039</span> */<a name="line.39"></a>
<span class="sourceLineNo">040</span>public class ReflectionUtil {<a name="line.40"></a>
<span class="sourceLineNo">041</span><a name="line.41"></a>
<span class="sourceLineNo">042</span>  /**<a name="line.42"></a>
<span class="sourceLineNo">043</span>   * Perform an unchecked cast based on a type parameter.<a name="line.43"></a>
<span class="sourceLineNo">044</span>   * <a name="line.44"></a>
<span class="sourceLineNo">045</span>   * @param &lt;T&gt;<a name="line.45"></a>
<span class="sourceLineNo">046</span>   *          The type to which the object should be cast.<a name="line.46"></a>
<span class="sourceLineNo">047</span>   * @param o<a name="line.47"></a>
<span class="sourceLineNo">048</span>   *          The object.<a name="line.48"></a>
<span class="sourceLineNo">049</span>   * @return The object, cast to the given type.<a name="line.49"></a>
<span class="sourceLineNo">050</span>   */<a name="line.50"></a>
<span class="sourceLineNo">051</span>  @SuppressWarnings("unchecked")<a name="line.51"></a>
<span class="sourceLineNo">052</span>  public static &lt;T&gt; T uncheckedCast(Object o) {<a name="line.52"></a>
<span class="sourceLineNo">053</span>    return (T) o;<a name="line.53"></a>
<span class="sourceLineNo">054</span>  }<a name="line.54"></a>
<span class="sourceLineNo">055</span><a name="line.55"></a>
<span class="sourceLineNo">056</span>  public static interface TypeArgumentDelegator {<a name="line.56"></a>
<span class="sourceLineNo">057</span>    public Map&lt;String, Type&gt; getTypeArguments(Class&lt;?&gt; genericType);<a name="line.57"></a>
<span class="sourceLineNo">058</span>  }<a name="line.58"></a>
<span class="sourceLineNo">059</span><a name="line.59"></a>
<span class="sourceLineNo">060</span>  public static &lt;T&gt; Type getTypeArgument(Class&lt;T&gt; genericType, String typeParameterName, T obj) {<a name="line.60"></a>
<span class="sourceLineNo">061</span>    Map&lt;String, Type&gt; typeArguments = getTypeArguments(genericType, obj);<a name="line.61"></a>
<span class="sourceLineNo">062</span>    return typeArguments == null ? null : typeArguments.get(typeParameterName);<a name="line.62"></a>
<span class="sourceLineNo">063</span>  }<a name="line.63"></a>
<span class="sourceLineNo">064</span><a name="line.64"></a>
<span class="sourceLineNo">065</span>  /**<a name="line.65"></a>
<span class="sourceLineNo">066</span>   * Try to find the instantiation of all of genericTypes type parameters in objs class.<a name="line.66"></a>
<span class="sourceLineNo">067</span>   * <a name="line.67"></a>
<span class="sourceLineNo">068</span>   * @param genericType<a name="line.68"></a>
<span class="sourceLineNo">069</span>   *          the generic supertype of objs class<a name="line.69"></a>
<span class="sourceLineNo">070</span>   * @param obj<a name="line.70"></a>
<span class="sourceLineNo">071</span>   *          an instantiation of a subclass of genericType. All of genericTypes type parameters<a name="line.71"></a>
<span class="sourceLineNo">072</span>   *          must have been instantiated in the inheritance hierarchy.<a name="line.72"></a>
<span class="sourceLineNo">073</span>   * @return a map of genericTypes type parameters (their name in the source code) to the type they<a name="line.73"></a>
<span class="sourceLineNo">074</span>   *         are instantiated as in obj<a name="line.74"></a>
<span class="sourceLineNo">075</span>   */<a name="line.75"></a>
<span class="sourceLineNo">076</span>  public static Map&lt;String, Type&gt; getTypeArguments(Class&lt;?&gt; genericType, Object obj) {<a name="line.76"></a>
<span class="sourceLineNo">077</span>    if (obj instanceof TypeArgumentDelegator) {<a name="line.77"></a>
<span class="sourceLineNo">078</span>      return ((TypeArgumentDelegator) obj).getTypeArguments(genericType);<a name="line.78"></a>
<span class="sourceLineNo">079</span>    }<a name="line.79"></a>
<span class="sourceLineNo">080</span>    Map&lt;String, Type&gt; typeMap = new TreeMap&lt;String, Type&gt;();<a name="line.80"></a>
<span class="sourceLineNo">081</span>    return getTypeArguments(genericType, obj.getClass(), typeMap);<a name="line.81"></a>
<span class="sourceLineNo">082</span>  }<a name="line.82"></a>
<span class="sourceLineNo">083</span><a name="line.83"></a>
<span class="sourceLineNo">084</span>  public static boolean isAssignableFrom(Type type1, Type type2) {<a name="line.84"></a>
<span class="sourceLineNo">085</span>    if (type1 instanceof Class&lt;?&gt; &amp;&amp; type2 instanceof Class&lt;?&gt;) {<a name="line.85"></a>
<span class="sourceLineNo">086</span>      return ((Class&lt;?&gt;) type1).isAssignableFrom((Class&lt;?&gt;) type2);<a name="line.86"></a>
<span class="sourceLineNo">087</span>    } else {<a name="line.87"></a>
<span class="sourceLineNo">088</span>      return type1.equals(type2);<a name="line.88"></a>
<span class="sourceLineNo">089</span>    }<a name="line.89"></a>
<span class="sourceLineNo">090</span>  }<a name="line.90"></a>
<span class="sourceLineNo">091</span><a name="line.91"></a>
<span class="sourceLineNo">092</span>  private static Map&lt;String, Type&gt; getTypeArguments(<a name="line.92"></a>
<span class="sourceLineNo">093</span>      Class&lt;?&gt; genericType,<a name="line.93"></a>
<span class="sourceLineNo">094</span>      Type type,<a name="line.94"></a>
<span class="sourceLineNo">095</span>      Map&lt;String, Type&gt; typeMap) {<a name="line.95"></a>
<span class="sourceLineNo">096</span>    if (type instanceof ParameterizedType) {<a name="line.96"></a>
<span class="sourceLineNo">097</span>      return getTypeArguments(genericType, (ParameterizedType) type, typeMap);<a name="line.97"></a>
<span class="sourceLineNo">098</span>    } else if (type instanceof Class&lt;?&gt;) {<a name="line.98"></a>
<span class="sourceLineNo">099</span>      return getTypeArguments(genericType, (Class&lt;?&gt;) type, typeMap);<a name="line.99"></a>
<span class="sourceLineNo">100</span>    } else {<a name="line.100"></a>
<span class="sourceLineNo">101</span>      throw new IllegalArgumentException("type must be a ParameterizedType or Class");<a name="line.101"></a>
<span class="sourceLineNo">102</span>    }<a name="line.102"></a>
<span class="sourceLineNo">103</span>  }<a name="line.103"></a>
<span class="sourceLineNo">104</span><a name="line.104"></a>
<span class="sourceLineNo">105</span>  private static Map&lt;String, Type&gt; getTypeArguments(<a name="line.105"></a>
<span class="sourceLineNo">106</span>      Class&lt;?&gt; genericType,<a name="line.106"></a>
<span class="sourceLineNo">107</span>      Class&lt;?&gt; classType,<a name="line.107"></a>
<span class="sourceLineNo">108</span>      Map&lt;String, Type&gt; typeMap) {<a name="line.108"></a>
<span class="sourceLineNo">109</span>    if (genericType.isInterface()) {<a name="line.109"></a>
<span class="sourceLineNo">110</span>      for (Type interfaceType : classType.getGenericInterfaces()) {<a name="line.110"></a>
<span class="sourceLineNo">111</span>        Map&lt;String, Type&gt; result = getTypeArguments(genericType, interfaceType, typeMap);<a name="line.111"></a>
<span class="sourceLineNo">112</span>        if (result != null)<a name="line.112"></a>
<span class="sourceLineNo">113</span>          return result;<a name="line.113"></a>
<span class="sourceLineNo">114</span>      }<a name="line.114"></a>
<span class="sourceLineNo">115</span>    }<a name="line.115"></a>
<span class="sourceLineNo">116</span><a name="line.116"></a>
<span class="sourceLineNo">117</span>    Type superType = classType.getGenericSuperclass();<a name="line.117"></a>
<span class="sourceLineNo">118</span>    if (superType != null) {<a name="line.118"></a>
<span class="sourceLineNo">119</span>      return getTypeArguments(genericType, superType, typeMap);<a name="line.119"></a>
<span class="sourceLineNo">120</span>    }<a name="line.120"></a>
<span class="sourceLineNo">121</span><a name="line.121"></a>
<span class="sourceLineNo">122</span>    return null;<a name="line.122"></a>
<span class="sourceLineNo">123</span>  }<a name="line.123"></a>
<span class="sourceLineNo">124</span><a name="line.124"></a>
<span class="sourceLineNo">125</span>  private static Map&lt;String, Type&gt; getTypeArguments(<a name="line.125"></a>
<span class="sourceLineNo">126</span>      Class&lt;?&gt; genericType,<a name="line.126"></a>
<span class="sourceLineNo">127</span>      ParameterizedType paramType,<a name="line.127"></a>
<span class="sourceLineNo">128</span>      Map&lt;String, Type&gt; typeMap) {<a name="line.128"></a>
<span class="sourceLineNo">129</span>    Class&lt;?&gt; rawType = (Class&lt;?&gt;) paramType.getRawType();<a name="line.129"></a>
<span class="sourceLineNo">130</span>    if (rawType == genericType) {<a name="line.130"></a>
<span class="sourceLineNo">131</span>      // found it!<a name="line.131"></a>
<span class="sourceLineNo">132</span>      TypeVariable&lt;?&gt; typeVars[] = rawType.getTypeParameters();<a name="line.132"></a>
<span class="sourceLineNo">133</span>      Type actualTypes[] = paramType.getActualTypeArguments();<a name="line.133"></a>
<span class="sourceLineNo">134</span>      Map&lt;String, Type&gt; result = new TreeMap&lt;String, Type&gt;();<a name="line.134"></a>
<span class="sourceLineNo">135</span>      for (int i = 0; i &lt; actualTypes.length; i++) {<a name="line.135"></a>
<span class="sourceLineNo">136</span>        while (actualTypes[i] != null &amp;&amp; actualTypes[i] instanceof TypeVariable&lt;?&gt;) {<a name="line.136"></a>
<span class="sourceLineNo">137</span>          String key = typevarString((TypeVariable&lt;?&gt;) actualTypes[i]);<a name="line.137"></a>
<span class="sourceLineNo">138</span>          if (typeMap.containsKey(key))<a name="line.138"></a>
<span class="sourceLineNo">139</span>            actualTypes[i] = typeMap.get(key);<a name="line.139"></a>
<span class="sourceLineNo">140</span>          else<a name="line.140"></a>
<span class="sourceLineNo">141</span>            actualTypes[i] = null;<a name="line.141"></a>
<span class="sourceLineNo">142</span>        }<a name="line.142"></a>
<span class="sourceLineNo">143</span>        result.put(typeVars[i].getName(), actualTypes[i]);<a name="line.143"></a>
<span class="sourceLineNo">144</span>      }<a name="line.144"></a>
<span class="sourceLineNo">145</span>      return result;<a name="line.145"></a>
<span class="sourceLineNo">146</span>    } else {<a name="line.146"></a>
<span class="sourceLineNo">147</span>      TypeVariable&lt;?&gt; typeVars[] = rawType.getTypeParameters();<a name="line.147"></a>
<span class="sourceLineNo">148</span>      Type actualTypes[] = paramType.getActualTypeArguments();<a name="line.148"></a>
<span class="sourceLineNo">149</span>      for (int i = 0; i &lt; typeVars.length; i++)<a name="line.149"></a>
<span class="sourceLineNo">150</span>        typeMap.put(typevarString(typeVars[i]), actualTypes[i]);<a name="line.150"></a>
<span class="sourceLineNo">151</span>      return getTypeArguments(genericType, paramType.getRawType(), typeMap);<a name="line.151"></a>
<span class="sourceLineNo">152</span>    }<a name="line.152"></a>
<span class="sourceLineNo">153</span>  }<a name="line.153"></a>
<span class="sourceLineNo">154</span><a name="line.154"></a>
<span class="sourceLineNo">155</span>  private static String typevarString(TypeVariable&lt;?&gt; tv) {<a name="line.155"></a>
<span class="sourceLineNo">156</span>    return tv.getGenericDeclaration().toString() + " " + tv.getName();<a name="line.156"></a>
<span class="sourceLineNo">157</span>  }<a name="line.157"></a>
<span class="sourceLineNo">158</span><a name="line.158"></a>
<span class="sourceLineNo">159</span>  /**<a name="line.159"></a>
<span class="sourceLineNo">160</span>   * Checks that the given type parameters of the given objects are compatible.<a name="line.160"></a>
<span class="sourceLineNo">161</span>   * <a name="line.161"></a>
<span class="sourceLineNo">162</span>   * Type parameters are identified by providing the class in which the type parameter is defined,<a name="line.162"></a>
<span class="sourceLineNo">163</span>   * and the declared name of the type parameter.<a name="line.163"></a>
<span class="sourceLineNo">164</span>   * <a name="line.164"></a>
<span class="sourceLineNo">165</span>   * Throws a ResourceInitializationException if the type parameters are not compatible.<a name="line.165"></a>
<span class="sourceLineNo">166</span>   * <a name="line.166"></a>
<span class="sourceLineNo">167</span>   * @param &lt;T&gt;<a name="line.167"></a>
<span class="sourceLineNo">168</span>   *          Type of the class declaring the first type parameter<a name="line.168"></a>
<span class="sourceLineNo">169</span>   * @param &lt;U&gt;<a name="line.169"></a>
<span class="sourceLineNo">170</span>   *          Type of the class declaring the second type parameter<a name="line.170"></a>
<span class="sourceLineNo">171</span>   * @param paramDefiningClass1<a name="line.171"></a>
<span class="sourceLineNo">172</span>   *          The class declaring the first type parameter<a name="line.172"></a>
<span class="sourceLineNo">173</span>   * @param paramName1<a name="line.173"></a>
<span class="sourceLineNo">174</span>   *          The declared name of the first type parameter<a name="line.174"></a>
<span class="sourceLineNo">175</span>   * @param object1<a name="line.175"></a>
<span class="sourceLineNo">176</span>   *          The target object<a name="line.176"></a>
<span class="sourceLineNo">177</span>   * @param paramDefiningClass2<a name="line.177"></a>
<span class="sourceLineNo">178</span>   *          The class declaring the second type parameter<a name="line.178"></a>
<span class="sourceLineNo">179</span>   * @param paramName2<a name="line.179"></a>
<span class="sourceLineNo">180</span>   *          The declared name of the second type parameter<a name="line.180"></a>
<span class="sourceLineNo">181</span>   * @param object2<a name="line.181"></a>
<span class="sourceLineNo">182</span>   *          The source object<a name="line.182"></a>
<span class="sourceLineNo">183</span>   */<a name="line.183"></a>
<span class="sourceLineNo">184</span>  public static &lt;T, U&gt; void checkTypeParameterIsAssignable(<a name="line.184"></a>
<span class="sourceLineNo">185</span>      Class&lt;T&gt; paramDefiningClass1,<a name="line.185"></a>
<span class="sourceLineNo">186</span>      String paramName1,<a name="line.186"></a>
<span class="sourceLineNo">187</span>      T object1,<a name="line.187"></a>
<span class="sourceLineNo">188</span>      Class&lt;U&gt; paramDefiningClass2,<a name="line.188"></a>
<span class="sourceLineNo">189</span>      String paramName2,<a name="line.189"></a>
<span class="sourceLineNo">190</span>      U object2) throws ResourceInitializationException {<a name="line.190"></a>
<span class="sourceLineNo">191</span><a name="line.191"></a>
<span class="sourceLineNo">192</span>    // get the type arguments from the objects<a name="line.192"></a>
<span class="sourceLineNo">193</span>    java.lang.reflect.Type type1 = ReflectionUtil.getTypeArgument(<a name="line.193"></a>
<span class="sourceLineNo">194</span>        paramDefiningClass1,<a name="line.194"></a>
<span class="sourceLineNo">195</span>        paramName1,<a name="line.195"></a>
<span class="sourceLineNo">196</span>        object1);<a name="line.196"></a>
<span class="sourceLineNo">197</span>    java.lang.reflect.Type type2 = ReflectionUtil.getTypeArgument(<a name="line.197"></a>
<span class="sourceLineNo">198</span>        paramDefiningClass2,<a name="line.198"></a>
<span class="sourceLineNo">199</span>        paramName2,<a name="line.199"></a>
<span class="sourceLineNo">200</span>        object2);<a name="line.200"></a>
<span class="sourceLineNo">201</span><a name="line.201"></a>
<span class="sourceLineNo">202</span>    // both arguments missing is compatible<a name="line.202"></a>
<span class="sourceLineNo">203</span>    if (type1 == null &amp;&amp; type2 == null) {<a name="line.203"></a>
<span class="sourceLineNo">204</span>      return;<a name="line.204"></a>
<span class="sourceLineNo">205</span>    }<a name="line.205"></a>
<span class="sourceLineNo">206</span><a name="line.206"></a>
<span class="sourceLineNo">207</span>    // if the second type is not assignable to the first, raise an exception<a name="line.207"></a>
<span class="sourceLineNo">208</span>    if (type1 == null || type2 == null || !ReflectionUtil.isAssignableFrom(type1, type2)) {<a name="line.208"></a>
<span class="sourceLineNo">209</span>      throw CleartkInitializationException.incompatibleTypeParameters(<a name="line.209"></a>
<span class="sourceLineNo">210</span>          object1,<a name="line.210"></a>
<span class="sourceLineNo">211</span>          paramName1,<a name="line.211"></a>
<span class="sourceLineNo">212</span>          type1,<a name="line.212"></a>
<span class="sourceLineNo">213</span>          object2,<a name="line.213"></a>
<span class="sourceLineNo">214</span>          paramName2,<a name="line.214"></a>
<span class="sourceLineNo">215</span>          type2);<a name="line.215"></a>
<span class="sourceLineNo">216</span>    }<a name="line.216"></a>
<span class="sourceLineNo">217</span>  }<a name="line.217"></a>
<span class="sourceLineNo">218</span><a name="line.218"></a>
<span class="sourceLineNo">219</span>  /**<a name="line.219"></a>
<span class="sourceLineNo">220</span>   * Checks that the given type parameters of the given objects are exactly equal.<a name="line.220"></a>
<span class="sourceLineNo">221</span>   * <a name="line.221"></a>
<span class="sourceLineNo">222</span>   * Type parameters are identified by providing the class in which the type parameter is defined,<a name="line.222"></a>
<span class="sourceLineNo">223</span>   * and the declared name of the type parameter.<a name="line.223"></a>
<span class="sourceLineNo">224</span>   * <a name="line.224"></a>
<span class="sourceLineNo">225</span>   * Throws an instance of the given exception class if type parameters are not exactly equal.<a name="line.225"></a>
<span class="sourceLineNo">226</span>   * <a name="line.226"></a>
<span class="sourceLineNo">227</span>   * @param &lt;T&gt;<a name="line.227"></a>
<span class="sourceLineNo">228</span>   *          Type of the class declaring the first type parameter<a name="line.228"></a>
<span class="sourceLineNo">229</span>   * @param &lt;U&gt;<a name="line.229"></a>
<span class="sourceLineNo">230</span>   *          Type of the class declaring the second type parameter<a name="line.230"></a>
<span class="sourceLineNo">231</span>   * @param paramDefiningClass1<a name="line.231"></a>
<span class="sourceLineNo">232</span>   *          The class declaring the first type parameter<a name="line.232"></a>
<span class="sourceLineNo">233</span>   * @param paramName1<a name="line.233"></a>
<span class="sourceLineNo">234</span>   *          The declared name of the first type parameter<a name="line.234"></a>
<span class="sourceLineNo">235</span>   * @param object1<a name="line.235"></a>
<span class="sourceLineNo">236</span>   *          The target object<a name="line.236"></a>
<span class="sourceLineNo">237</span>   * @param paramDefiningClass2<a name="line.237"></a>
<span class="sourceLineNo">238</span>   *          The class declaring the second type parameter<a name="line.238"></a>
<span class="sourceLineNo">239</span>   * @param paramName2<a name="line.239"></a>
<span class="sourceLineNo">240</span>   *          The declared name of the second type parameter<a name="line.240"></a>
<span class="sourceLineNo">241</span>   * @param object2<a name="line.241"></a>
<span class="sourceLineNo">242</span>   *          The source object<a name="line.242"></a>
<span class="sourceLineNo">243</span>   */<a name="line.243"></a>
<span class="sourceLineNo">244</span>  public static &lt;T, U, E extends Exception&gt; void checkTypeParametersAreEqual(<a name="line.244"></a>
<span class="sourceLineNo">245</span>      Class&lt;T&gt; paramDefiningClass1,<a name="line.245"></a>
<span class="sourceLineNo">246</span>      String paramName1,<a name="line.246"></a>
<span class="sourceLineNo">247</span>      T object1,<a name="line.247"></a>
<span class="sourceLineNo">248</span>      Class&lt;U&gt; paramDefiningClass2,<a name="line.248"></a>
<span class="sourceLineNo">249</span>      String paramName2,<a name="line.249"></a>
<span class="sourceLineNo">250</span>      U object2,<a name="line.250"></a>
<span class="sourceLineNo">251</span>      Class&lt;E&gt; exceptionClass) throws E {<a name="line.251"></a>
<span class="sourceLineNo">252</span><a name="line.252"></a>
<span class="sourceLineNo">253</span>    // get the type arguments from the objects<a name="line.253"></a>
<span class="sourceLineNo">254</span>    java.lang.reflect.Type type1 = ReflectionUtil.getTypeArgument(<a name="line.254"></a>
<span class="sourceLineNo">255</span>        paramDefiningClass1,<a name="line.255"></a>
<span class="sourceLineNo">256</span>        paramName1,<a name="line.256"></a>
<span class="sourceLineNo">257</span>        object1);<a name="line.257"></a>
<span class="sourceLineNo">258</span>    java.lang.reflect.Type type2 = ReflectionUtil.getTypeArgument(<a name="line.258"></a>
<span class="sourceLineNo">259</span>        paramDefiningClass2,<a name="line.259"></a>
<span class="sourceLineNo">260</span>        paramName2,<a name="line.260"></a>
<span class="sourceLineNo">261</span>        object2);<a name="line.261"></a>
<span class="sourceLineNo">262</span><a name="line.262"></a>
<span class="sourceLineNo">263</span>    // both arguments missing is equal<a name="line.263"></a>
<span class="sourceLineNo">264</span>    if (type1 == null &amp;&amp; type2 == null) {<a name="line.264"></a>
<span class="sourceLineNo">265</span>      return;<a name="line.265"></a>
<span class="sourceLineNo">266</span>    }<a name="line.266"></a>
<span class="sourceLineNo">267</span><a name="line.267"></a>
<span class="sourceLineNo">268</span>    // if the second type is not equal to the first, raise an exception<a name="line.268"></a>
<span class="sourceLineNo">269</span>    if (type1 == null || type2 == null || !type1.equals(type2)) {<a name="line.269"></a>
<span class="sourceLineNo">270</span>      try {<a name="line.270"></a>
<span class="sourceLineNo">271</span>        throw exceptionClass.getConstructor(String.class).newInstance(<a name="line.271"></a>
<span class="sourceLineNo">272</span>            String.format(<a name="line.272"></a>
<span class="sourceLineNo">273</span>                "%s with %s %s is not equal to %s with %s %s",<a name="line.273"></a>
<span class="sourceLineNo">274</span>                object1.getClass().getSimpleName(),<a name="line.274"></a>
<span class="sourceLineNo">275</span>                paramName1,<a name="line.275"></a>
<span class="sourceLineNo">276</span>                type1,<a name="line.276"></a>
<span class="sourceLineNo">277</span>                object2.getClass().getSimpleName(),<a name="line.277"></a>
<span class="sourceLineNo">278</span>                paramName2,<a name="line.278"></a>
<span class="sourceLineNo">279</span>                type2));<a name="line.279"></a>
<span class="sourceLineNo">280</span>      } catch (InstantiationException e) {<a name="line.280"></a>
<span class="sourceLineNo">281</span>        throw new RuntimeException(e);<a name="line.281"></a>
<span class="sourceLineNo">282</span>      } catch (IllegalAccessException e) {<a name="line.282"></a>
<span class="sourceLineNo">283</span>        throw new RuntimeException(e);<a name="line.283"></a>
<span class="sourceLineNo">284</span>      } catch (InvocationTargetException e) {<a name="line.284"></a>
<span class="sourceLineNo">285</span>        throw new RuntimeException(e);<a name="line.285"></a>
<span class="sourceLineNo">286</span>      } catch (NoSuchMethodException e) {<a name="line.286"></a>
<span class="sourceLineNo">287</span>        throw new RuntimeException(e);<a name="line.287"></a>
<span class="sourceLineNo">288</span>      }<a name="line.288"></a>
<span class="sourceLineNo">289</span>    }<a name="line.289"></a>
<span class="sourceLineNo">290</span>  }<a name="line.290"></a>
<span class="sourceLineNo">291</span><a name="line.291"></a>
<span class="sourceLineNo">292</span>}<a name="line.292"></a>




























































</pre>
</div>
</body>
</html>
