<HTML>
<BODY BGCOLOR="white">
<PRE>
<FONT color="green">001</FONT>    /** <a name="line.1"></a>
<FONT color="green">002</FONT>     * Copyright (c) 2007-2008, Regents of the University of Colorado <a name="line.2"></a>
<FONT color="green">003</FONT>     * All rights reserved.<a name="line.3"></a>
<FONT color="green">004</FONT>     * <a name="line.4"></a>
<FONT color="green">005</FONT>     * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<FONT color="green">006</FONT>     * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<FONT color="green">007</FONT>     * <a name="line.7"></a>
<FONT color="green">008</FONT>     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<FONT color="green">009</FONT>     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<FONT color="green">010</FONT>     * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<FONT color="green">011</FONT>     * <a name="line.11"></a>
<FONT color="green">012</FONT>     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<FONT color="green">013</FONT>     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<FONT color="green">014</FONT>     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<FONT color="green">015</FONT>     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<FONT color="green">016</FONT>     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<FONT color="green">017</FONT>     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<FONT color="green">018</FONT>     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<FONT color="green">019</FONT>     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<FONT color="green">020</FONT>     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<FONT color="green">021</FONT>     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<FONT color="green">022</FONT>     * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<FONT color="green">023</FONT>     */<a name="line.23"></a>
<FONT color="green">024</FONT>    package org.cleartk.syntax.constituent.util;<a name="line.24"></a>
<FONT color="green">025</FONT>    <a name="line.25"></a>
<FONT color="green">026</FONT>    import java.util.ArrayList;<a name="line.26"></a>
<FONT color="green">027</FONT>    import java.util.List;<a name="line.27"></a>
<FONT color="green">028</FONT>    import java.util.Stack;<a name="line.28"></a>
<FONT color="green">029</FONT>    import java.util.regex.Matcher;<a name="line.29"></a>
<FONT color="green">030</FONT>    import java.util.regex.Pattern;<a name="line.30"></a>
<FONT color="green">031</FONT>    <a name="line.31"></a>
<FONT color="green">032</FONT>    /**<a name="line.32"></a>
<FONT color="green">033</FONT>     * &lt;br&gt;<a name="line.33"></a>
<FONT color="green">034</FONT>     * Copyright (c) 2007-2008, Regents of the University of Colorado &lt;br&gt;<a name="line.34"></a>
<FONT color="green">035</FONT>     * All rights reserved.<a name="line.35"></a>
<FONT color="green">036</FONT>     * <a name="line.36"></a>
<FONT color="green">037</FONT>     * <a name="line.37"></a>
<FONT color="green">038</FONT>     * @author Philip Ogren<a name="line.38"></a>
<FONT color="green">039</FONT>     * <a name="line.39"></a>
<FONT color="green">040</FONT>     *         This class was written to be a stand alone parser for the Penn Treebank data. Basically,<a name="line.40"></a>
<FONT color="green">041</FONT>     *         I need a way to synch up the propbank data with extents of plain text that are labeled.<a name="line.41"></a>
<FONT color="green">042</FONT>     *         This is not possible to do without parsing the treebank data first. The parse method will<a name="line.42"></a>
<FONT color="green">043</FONT>     *         parse a single sentence from the treebank data from e.g. wsj/mrg/06/wsj_0656.mrg.<a name="line.43"></a>
<FONT color="green">044</FONT>     * <a name="line.44"></a>
<FONT color="green">045</FONT>     *         I initially looked at the OpenNLP treebank parser but they made a few assumptions about<a name="line.45"></a>
<FONT color="green">046</FONT>     *         they wanted to keep for the parser that would make it difficult to align with the<a name="line.46"></a>
<FONT color="green">047</FONT>     *         propbank data. See: https://sourceforge<a name="line.47"></a>
<FONT color="green">048</FONT>     *         .net/forum/forum.php?thread_id=1751983&amp;forum_id=9943 for relevant discussion. I looked at<a name="line.48"></a>
<FONT color="green">049</FONT>     *         their parsing implementation and tried to modify it. However, I think the code below<a name="line.49"></a>
<FONT color="green">050</FONT>     *         bears little resemblance to theirs. But there may yet be some snippets taken directly out<a name="line.50"></a>
<FONT color="green">051</FONT>     *         of that code. The two regular expressions used are very similar.<a name="line.51"></a>
<FONT color="green">052</FONT>     * <a name="line.52"></a>
<FONT color="green">053</FONT>     * @see opennlp.tools.parser.Parse#parseParse(String)<a name="line.53"></a>
<FONT color="green">054</FONT>     */<a name="line.54"></a>
<FONT color="green">055</FONT>    public class TreebankFormatParser {<a name="line.55"></a>
<FONT color="green">056</FONT>      /**<a name="line.56"></a>
<FONT color="green">057</FONT>       * used to identify tokens in Penn Treebank labeled constituents. It will match strings such as:<a name="line.57"></a>
<FONT color="green">058</FONT>       * &lt;ul&gt;<a name="line.58"></a>
<FONT color="green">059</FONT>       * &lt;li&gt;(NNP Community)<a name="line.59"></a>
<FONT color="green">060</FONT>       * &lt;li&gt;(: --)<a name="line.60"></a>
<FONT color="green">061</FONT>       * &lt;li&gt;(-NONE- *U*)<a name="line.61"></a>
<FONT color="green">062</FONT>       * &lt;/ul&gt;<a name="line.62"></a>
<FONT color="green">063</FONT>       */<a name="line.63"></a>
<FONT color="green">064</FONT>      public static final String LEAF_NODE_REGEX = "\\(([^( )]+) ([^( )]+)\\s*\\)";<a name="line.64"></a>
<FONT color="green">065</FONT>    <a name="line.65"></a>
<FONT color="green">066</FONT>      private static Pattern leafNodePattern = Pattern.compile(LEAF_NODE_REGEX);<a name="line.66"></a>
<FONT color="green">067</FONT>    <a name="line.67"></a>
<FONT color="green">068</FONT>      /**<a name="line.68"></a>
<FONT color="green">069</FONT>       * Uses the leafNodePattern to identify a string as a terminal. Examples:<a name="line.69"></a>
<FONT color="green">070</FONT>       * &lt;ul&gt;<a name="line.70"></a>
<FONT color="green">071</FONT>       * &lt;li&gt;parseFragment = "(NNP Community)", returns a leaf node<a name="line.71"></a>
<FONT color="green">072</FONT>       * &lt;li&gt;parseFragment = "(QP ($ $) (CD 107) (CD million) )", returns null<a name="line.72"></a>
<FONT color="green">073</FONT>       * &lt;/ul&gt;<a name="line.73"></a>
<FONT color="green">074</FONT>       * <a name="line.74"></a>
<FONT color="green">075</FONT>       * @param parseFragment<a name="line.75"></a>
<FONT color="green">076</FONT>       *          some fragment of a treebank parse.<a name="line.76"></a>
<FONT color="green">077</FONT>       * @return if the string matches, then a node will be returned. Otherwise, null is returned.<a name="line.77"></a>
<FONT color="green">078</FONT>       */<a name="line.78"></a>
<FONT color="green">079</FONT>      protected static TreebankNode getLeafNode(String parseFragment) {<a name="line.79"></a>
<FONT color="green">080</FONT>        Matcher leafNodeMatcher = leafNodePattern.matcher(parseFragment);<a name="line.80"></a>
<FONT color="green">081</FONT>        if (leafNodeMatcher.matches()) {<a name="line.81"></a>
<FONT color="green">082</FONT>          String type = leafNodeMatcher.group(1);<a name="line.82"></a>
<FONT color="green">083</FONT>          String value = leafNodeMatcher.group(2);<a name="line.83"></a>
<FONT color="green">084</FONT>          TreebankNode node = new TreebankNode();<a name="line.84"></a>
<FONT color="green">085</FONT>          node.setType(getTypeFromType(type));<a name="line.85"></a>
<FONT color="green">086</FONT>          node.setTags(getTagsFromType(type));<a name="line.86"></a>
<FONT color="green">087</FONT>          node.setValue(value);<a name="line.87"></a>
<FONT color="green">088</FONT>          node.setLeaf(true);<a name="line.88"></a>
<FONT color="green">089</FONT>          // the token and the value will almost always be the same except for<a name="line.89"></a>
<FONT color="green">090</FONT>          // a few special values (e.g. "-RCB-", "-LCB-", and "-NONE-")<a name="line.90"></a>
<FONT color="green">091</FONT>          String token = getToken(node.getValue(), node.getType());<a name="line.91"></a>
<FONT color="green">092</FONT>          node.setText(token);<a name="line.92"></a>
<FONT color="green">093</FONT>          return node;<a name="line.93"></a>
<FONT color="green">094</FONT>        }<a name="line.94"></a>
<FONT color="green">095</FONT>        return null;<a name="line.95"></a>
<FONT color="green">096</FONT>      }<a name="line.96"></a>
<FONT color="green">097</FONT>    <a name="line.97"></a>
<FONT color="green">098</FONT>      private static String getTypeFromType(String fullType) {<a name="line.98"></a>
<FONT color="green">099</FONT>        if (fullType.startsWith("-"))<a name="line.99"></a>
<FONT color="green">100</FONT>          return fullType.substring(0, fullType.indexOf('-', 1) + 1);<a name="line.100"></a>
<FONT color="green">101</FONT>    <a name="line.101"></a>
<FONT color="green">102</FONT>        return fullType.split("[-=]")[0];<a name="line.102"></a>
<FONT color="green">103</FONT>      }<a name="line.103"></a>
<FONT color="green">104</FONT>    <a name="line.104"></a>
<FONT color="green">105</FONT>      private static String[] getTagsFromType(String fullType) {<a name="line.105"></a>
<FONT color="green">106</FONT>        if (fullType.startsWith("-")) {<a name="line.106"></a>
<FONT color="green">107</FONT>          String rest = fullType.substring(fullType.indexOf('-', 1) + 1);<a name="line.107"></a>
<FONT color="green">108</FONT>          if (rest.length() &gt; 0)<a name="line.108"></a>
<FONT color="green">109</FONT>            return rest.split("[-=]");<a name="line.109"></a>
<FONT color="green">110</FONT>          else<a name="line.110"></a>
<FONT color="green">111</FONT>            return new String[0];<a name="line.111"></a>
<FONT color="green">112</FONT>        } else {<a name="line.112"></a>
<FONT color="green">113</FONT>          String[] parts = fullType.split("[-=]");<a name="line.113"></a>
<FONT color="green">114</FONT>          String[] tags = new String[parts.length - 1];<a name="line.114"></a>
<FONT color="green">115</FONT>    <a name="line.115"></a>
<FONT color="green">116</FONT>          for (int i = 1; i &lt; parts.length; i++)<a name="line.116"></a>
<FONT color="green">117</FONT>            tags[i - 1] = parts[i];<a name="line.117"></a>
<FONT color="green">118</FONT>          return tags;<a name="line.118"></a>
<FONT color="green">119</FONT>        }<a name="line.119"></a>
<FONT color="green">120</FONT>      }<a name="line.120"></a>
<FONT color="green">121</FONT>    <a name="line.121"></a>
<FONT color="green">122</FONT>      /**<a name="line.122"></a>
<FONT color="green">123</FONT>       * used to identify the type of a consituent in a treebank parse tree. It will match strings such<a name="line.123"></a>
<FONT color="green">124</FONT>       * as:<a name="line.124"></a>
<FONT color="green">125</FONT>       * &lt;ul&gt;<a name="line.125"></a>
<FONT color="green">126</FONT>       * &lt;li&gt;"NNP" in "(NNP Community)"<a name="line.126"></a>
<FONT color="green">127</FONT>       * &lt;li&gt;":" in "(: --)"<a name="line.127"></a>
<FONT color="green">128</FONT>       * &lt;li&gt;"-NONE-" in "(-NONE- *U*)"<a name="line.128"></a>
<FONT color="green">129</FONT>       * &lt;/ul&gt;<a name="line.129"></a>
<FONT color="green">130</FONT>       */<a name="line.130"></a>
<FONT color="green">131</FONT>      public static final String TYPE_REGEX = "^\\(([^() ]+)";<a name="line.131"></a>
<FONT color="green">132</FONT>    <a name="line.132"></a>
<FONT color="green">133</FONT>      private static Pattern typePattern = Pattern.compile(TYPE_REGEX);<a name="line.133"></a>
<FONT color="green">134</FONT>    <a name="line.134"></a>
<FONT color="green">135</FONT>      /**<a name="line.135"></a>
<FONT color="green">136</FONT>       * Returns the type of a constituent of some fragment of a treebank parse. Assumes that the first<a name="line.136"></a>
<FONT color="green">137</FONT>       * character is a parenthesis. Examples:<a name="line.137"></a>
<FONT color="green">138</FONT>       * &lt;ul&gt;<a name="line.138"></a>
<FONT color="green">139</FONT>       * &lt;li&gt;parseFragment = "(NP-LOC (NNP Calif.) )" return = "NP-LOC"<a name="line.139"></a>
<FONT color="green">140</FONT>       * &lt;li&gt;parseFragment = "(NP" return "NP"<a name="line.140"></a>
<FONT color="green">141</FONT>       * &lt;li&gt;parseFragment = "(-NONE- *U*) ) (PP (IN of)" return = "-NONE-"<a name="line.141"></a>
<FONT color="green">142</FONT>       * &lt;/ul&gt;<a name="line.142"></a>
<FONT color="green">143</FONT>       * <a name="line.143"></a>
<FONT color="green">144</FONT>       * @param parseFragment<a name="line.144"></a>
<FONT color="green">145</FONT>       *          some fragment of a treebank parse<a name="line.145"></a>
<FONT color="green">146</FONT>       * @return the type of the constituent.<a name="line.146"></a>
<FONT color="green">147</FONT>       */<a name="line.147"></a>
<FONT color="green">148</FONT>      protected static String getType(String parseFragment) {<a name="line.148"></a>
<FONT color="green">149</FONT>        Matcher typeMatcher = typePattern.matcher(parseFragment);<a name="line.149"></a>
<FONT color="green">150</FONT>        if (typeMatcher.find())<a name="line.150"></a>
<FONT color="green">151</FONT>          return typeMatcher.group(1);<a name="line.151"></a>
<FONT color="green">152</FONT>        return null;<a name="line.152"></a>
<FONT color="green">153</FONT>      }<a name="line.153"></a>
<FONT color="green">154</FONT>    <a name="line.154"></a>
<FONT color="green">155</FONT>      public static final String cleanUPRegex1 = "\\s+";<a name="line.155"></a>
<FONT color="green">156</FONT>    <a name="line.156"></a>
<FONT color="green">157</FONT>      private static final Pattern cleanUpPattern1 = Pattern.compile(cleanUPRegex1, Pattern.MULTILINE);<a name="line.157"></a>
<FONT color="green">158</FONT>    <a name="line.158"></a>
<FONT color="green">159</FONT>      public static final String cleanUPRegex2 = "\\( \\(";<a name="line.159"></a>
<FONT color="green">160</FONT>    <a name="line.160"></a>
<FONT color="green">161</FONT>      private static final Pattern cleanUpPattern2 = Pattern.compile(cleanUPRegex2, Pattern.MULTILINE);<a name="line.161"></a>
<FONT color="green">162</FONT>    <a name="line.162"></a>
<FONT color="green">163</FONT>      public static final String cleanUPRegex3 = "\\) \\)";<a name="line.163"></a>
<FONT color="green">164</FONT>    <a name="line.164"></a>
<FONT color="green">165</FONT>      private static final Pattern cleanUpPattern3 = Pattern.compile(cleanUPRegex3, Pattern.MULTILINE);<a name="line.165"></a>
<FONT color="green">166</FONT>    <a name="line.166"></a>
<FONT color="green">167</FONT>      public static final String cleanUPRegex4 = "\\s*\\(\\s*\\(";<a name="line.167"></a>
<FONT color="green">168</FONT>    <a name="line.168"></a>
<FONT color="green">169</FONT>      private static final Pattern cleanUpPattern4 = Pattern.compile(cleanUPRegex4, Pattern.MULTILINE);<a name="line.169"></a>
<FONT color="green">170</FONT>    <a name="line.170"></a>
<FONT color="green">171</FONT>      /**<a name="line.171"></a>
<FONT color="green">172</FONT>       * This method was created simply as a way to clean up the parse string for a sentence in the<a name="line.172"></a>
<FONT color="green">173</FONT>       * treebank syntax. The most important thing that it does is add a type called TOP to the top node<a name="line.173"></a>
<FONT color="green">174</FONT>       * of the sentence. This simplifies parsing. The other string replacements just remove white space<a name="line.174"></a>
<FONT color="green">175</FONT>       * and such and are probably unnecessary. This was inspired by the OpenNLP solution which takes in<a name="line.175"></a>
<FONT color="green">176</FONT>       * one line at a time from a file that has been modified in this way.<a name="line.176"></a>
<FONT color="green">177</FONT>       * <a name="line.177"></a>
<FONT color="green">178</FONT>       * @param parse<a name="line.178"></a>
<FONT color="green">179</FONT>       *          a String in the treebank format<a name="line.179"></a>
<FONT color="green">180</FONT>       * @return a String in the treebank that has been cleaned up a bit.<a name="line.180"></a>
<FONT color="green">181</FONT>       */<a name="line.181"></a>
<FONT color="green">182</FONT>      public static String prepareString(String parse) {<a name="line.182"></a>
<FONT color="green">183</FONT>        parse = cleanUpPattern1.matcher(parse).replaceAll(" ");<a name="line.183"></a>
<FONT color="green">184</FONT>        parse = cleanUpPattern2.matcher(parse).replaceAll("((");<a name="line.184"></a>
<FONT color="green">185</FONT>        parse = cleanUpPattern3.matcher(parse).replaceAll("))");<a name="line.185"></a>
<FONT color="green">186</FONT>        parse = cleanUpPattern4.matcher(parse).replaceFirst("(TOP (");<a name="line.186"></a>
<FONT color="green">187</FONT>        return parse.trim();<a name="line.187"></a>
<FONT color="green">188</FONT>      }<a name="line.188"></a>
<FONT color="green">189</FONT>    <a name="line.189"></a>
<FONT color="green">190</FONT>      /**<a name="line.190"></a>
<FONT color="green">191</FONT>       * A treebank parse does not preserve whitespace information. This method provides a simple<a name="line.191"></a>
<FONT color="green">192</FONT>       * mechanism for inferring the original plain text of a treebank parse. If you have access to the<a name="line.192"></a>
<FONT color="green">193</FONT>       * original plain text, then you can bypass use of this method by calling the appropriate parse<a name="line.193"></a>
<FONT color="green">194</FONT>       * method.<a name="line.194"></a>
<FONT color="green">195</FONT>       * <a name="line.195"></a>
<FONT color="green">196</FONT>       * @see #parse(String, String, int)<a name="line.196"></a>
<FONT color="green">197</FONT>       * <a name="line.197"></a>
<FONT color="green">198</FONT>       * @param treebankText<a name="line.198"></a>
<FONT color="green">199</FONT>       *          One or more parses in Treebank parenthesized format.<a name="line.199"></a>
<FONT color="green">200</FONT>       * @return a "best" guess of the original plain text given in the parse.<a name="line.200"></a>
<FONT color="green">201</FONT>       */<a name="line.201"></a>
<FONT color="green">202</FONT>      public static String inferPlainText(String treebankText) {<a name="line.202"></a>
<FONT color="green">203</FONT>        StringBuilder sb = new StringBuilder();<a name="line.203"></a>
<FONT color="green">204</FONT>        for (String parse : splitSentences(treebankText)) {<a name="line.204"></a>
<FONT color="green">205</FONT>          Matcher matcher = leafNodePattern.matcher(parse);<a name="line.205"></a>
<FONT color="green">206</FONT>          while (matcher.find()) {<a name="line.206"></a>
<FONT color="green">207</FONT>            TreebankNode node = getLeafNode(matcher.group());<a name="line.207"></a>
<FONT color="green">208</FONT>            if (node.getText() != null &amp;&amp; node.getText().length() &gt; 0) {<a name="line.208"></a>
<FONT color="green">209</FONT>              int lastIndex = sb.length() - 1;<a name="line.209"></a>
<FONT color="green">210</FONT>              if (lastIndex &gt; 0 &amp;&amp; !needsSpaceBefore(node.getText()) &amp;&amp; sb.charAt(lastIndex) == ' ') {<a name="line.210"></a>
<FONT color="green">211</FONT>                sb.deleteCharAt(lastIndex);<a name="line.211"></a>
<FONT color="green">212</FONT>              }<a name="line.212"></a>
<FONT color="green">213</FONT>              sb.append(node.getText());<a name="line.213"></a>
<FONT color="green">214</FONT>              if (needsSpaceAfter(node.getText())) {<a name="line.214"></a>
<FONT color="green">215</FONT>                sb.append(" ");<a name="line.215"></a>
<FONT color="green">216</FONT>              }<a name="line.216"></a>
<FONT color="green">217</FONT>            }<a name="line.217"></a>
<FONT color="green">218</FONT>          }<a name="line.218"></a>
<FONT color="green">219</FONT>          int lastIndex = sb.length() - 1;<a name="line.219"></a>
<FONT color="green">220</FONT>          if (lastIndex &gt;= 0 &amp;&amp; sb.charAt(lastIndex) == ' ') {<a name="line.220"></a>
<FONT color="green">221</FONT>            sb.deleteCharAt(lastIndex);<a name="line.221"></a>
<FONT color="green">222</FONT>          }<a name="line.222"></a>
<FONT color="green">223</FONT>          sb.append('\n');<a name="line.223"></a>
<FONT color="green">224</FONT>        }<a name="line.224"></a>
<FONT color="green">225</FONT>        return sb.toString().trim();<a name="line.225"></a>
<FONT color="green">226</FONT>      }<a name="line.226"></a>
<FONT color="green">227</FONT>    <a name="line.227"></a>
<FONT color="green">228</FONT>      private static boolean needsSpaceBefore(String tokenText) {<a name="line.228"></a>
<FONT color="green">229</FONT>        String[] noSpaceTokens = new String[] {<a name="line.229"></a>
<FONT color="green">230</FONT>            ".",<a name="line.230"></a>
<FONT color="green">231</FONT>            ",",<a name="line.231"></a>
<FONT color="green">232</FONT>            ":",<a name="line.232"></a>
<FONT color="green">233</FONT>            ";",<a name="line.233"></a>
<FONT color="green">234</FONT>            "?",<a name="line.234"></a>
<FONT color="green">235</FONT>            "'s",<a name="line.235"></a>
<FONT color="green">236</FONT>            "'t",<a name="line.236"></a>
<FONT color="green">237</FONT>            "\"",<a name="line.237"></a>
<FONT color="green">238</FONT>            "!",<a name="line.238"></a>
<FONT color="green">239</FONT>            ")",<a name="line.239"></a>
<FONT color="green">240</FONT>            "]" };<a name="line.240"></a>
<FONT color="green">241</FONT>        for (String noSpaceToken : noSpaceTokens) {<a name="line.241"></a>
<FONT color="green">242</FONT>          if (tokenText.equals(noSpaceToken)) {<a name="line.242"></a>
<FONT color="green">243</FONT>            return false;<a name="line.243"></a>
<FONT color="green">244</FONT>          }<a name="line.244"></a>
<FONT color="green">245</FONT>        }<a name="line.245"></a>
<FONT color="green">246</FONT>        return true;<a name="line.246"></a>
<FONT color="green">247</FONT>      }<a name="line.247"></a>
<FONT color="green">248</FONT>    <a name="line.248"></a>
<FONT color="green">249</FONT>      private static boolean needsSpaceAfter(String tokenText) {<a name="line.249"></a>
<FONT color="green">250</FONT>        String[] noSpaceTokens = new String[] { "\"", "(", "[" };<a name="line.250"></a>
<FONT color="green">251</FONT>        for (String noSpaceToken : noSpaceTokens) {<a name="line.251"></a>
<FONT color="green">252</FONT>          if (tokenText.equals(noSpaceToken)) {<a name="line.252"></a>
<FONT color="green">253</FONT>            return false;<a name="line.253"></a>
<FONT color="green">254</FONT>          }<a name="line.254"></a>
<FONT color="green">255</FONT>        }<a name="line.255"></a>
<FONT color="green">256</FONT>        return true;<a name="line.256"></a>
<FONT color="green">257</FONT>      }<a name="line.257"></a>
<FONT color="green">258</FONT>    <a name="line.258"></a>
<FONT color="green">259</FONT>      /**<a name="line.259"></a>
<FONT color="green">260</FONT>       * Create TreebankNode objects corresponding to the given TreeBank format parse, e.g.:<a name="line.260"></a>
<FONT color="green">261</FONT>       * <a name="line.261"></a>
<FONT color="green">262</FONT>       * &lt;PRE&gt;<a name="line.262"></a>
<FONT color="green">263</FONT>       * ( (X (NP (NP (NML (NN Complex ) (NN trait )) (NN analysis )) (PP (IN of ) (NP (DT the ) (NN mouse ) (NN striatum )))) (: : ) (S (NP-SBJ (JJ independent ) (NNS QTLs )) (VP (VBP modulate ) (NP (NP (NN volume )) (CC and ) (NP (NN neuron ) (NN number)))))) )<a name="line.263"></a>
<FONT color="green">264</FONT>       * &lt;/PRE&gt;<a name="line.264"></a>
<FONT color="green">265</FONT>       * <a name="line.265"></a>
<FONT color="green">266</FONT>       * The text will be inferred automatically from the words in the parse.<a name="line.266"></a>
<FONT color="green">267</FONT>       * <a name="line.267"></a>
<FONT color="green">268</FONT>       * @param parse<a name="line.268"></a>
<FONT color="green">269</FONT>       *          A TreeBank formatted parse<a name="line.269"></a>
<FONT color="green">270</FONT>       * @return The TreebankNode root of the parse tree<a name="line.270"></a>
<FONT color="green">271</FONT>       * @see #inferPlainText(String)<a name="line.271"></a>
<FONT color="green">272</FONT>       * @see #parse(String, String, int)<a name="line.272"></a>
<FONT color="green">273</FONT>       */<a name="line.273"></a>
<FONT color="green">274</FONT>      public static TopTreebankNode parse(String parse) {<a name="line.274"></a>
<FONT color="green">275</FONT>        parse = prepareString(parse);<a name="line.275"></a>
<FONT color="green">276</FONT>        String plainText = inferPlainText(parse).trim();<a name="line.276"></a>
<FONT color="green">277</FONT>        return parse(parse, plainText, 0);<a name="line.277"></a>
<FONT color="green">278</FONT>      }<a name="line.278"></a>
<FONT color="green">279</FONT>    <a name="line.279"></a>
<FONT color="green">280</FONT>      private static void checkText(TreebankNode node, String text) {<a name="line.280"></a>
<FONT color="green">281</FONT>        String text1 = node.getText();<a name="line.281"></a>
<FONT color="green">282</FONT>        int start = node.getTextBegin();<a name="line.282"></a>
<FONT color="green">283</FONT>        int end = node.getTextEnd();<a name="line.283"></a>
<FONT color="green">284</FONT>        String text2 = text.substring(start, end);<a name="line.284"></a>
<FONT color="green">285</FONT>        if (!text1.equals(text2)) {<a name="line.285"></a>
<FONT color="green">286</FONT>          // TreeBank adds in (. .) nodes in odd places, e.g. when a sentence<a name="line.286"></a>
<FONT color="green">287</FONT>          // ends with U.S. (and no final period). As a result, we need to<a name="line.287"></a>
<FONT color="green">288</FONT>          // allow periods to match whitespace and adjust the node bounds.<a name="line.288"></a>
<FONT color="green">289</FONT>          String prefix1 = text1.substring(0, text1.length() - 1);<a name="line.289"></a>
<FONT color="green">290</FONT>          String prefix2 = text2.substring(0, text2.length() - 1);<a name="line.290"></a>
<FONT color="green">291</FONT>          if (text1.endsWith(".") &amp;&amp; prefix1.equals(prefix2)) {<a name="line.291"></a>
<FONT color="green">292</FONT>            node.setTextEnd(node.getTextEnd() - 1);<a name="line.292"></a>
<FONT color="green">293</FONT>          } else {<a name="line.293"></a>
<FONT color="green">294</FONT>            throw new IllegalArgumentException(<a name="line.294"></a>
<FONT color="green">295</FONT>                "plain text does not align with tokens in treebank parse.  node text = '" + text1<a name="line.295"></a>
<FONT color="green">296</FONT>                    + "'  plain text = '" + text2 + "'");<a name="line.296"></a>
<FONT color="green">297</FONT>          }<a name="line.297"></a>
<FONT color="green">298</FONT>        }<a name="line.298"></a>
<FONT color="green">299</FONT>      }<a name="line.299"></a>
<FONT color="green">300</FONT>    <a name="line.300"></a>
<FONT color="green">301</FONT>      /**<a name="line.301"></a>
<FONT color="green">302</FONT>       * Create TreebankNode objects corresponding to the given TreeBank format parse, e.g.:<a name="line.302"></a>
<FONT color="green">303</FONT>       * <a name="line.303"></a>
<FONT color="green">304</FONT>       * &lt;PRE&gt;<a name="line.304"></a>
<FONT color="green">305</FONT>       * ( (X (NP (NP (NML (NN Complex ) (NN trait )) (NN analysis )) (PP (IN of ) (NP (DT the ) (NN mouse ) (NN striatum )))) (: : ) (S (NP-SBJ (JJ independent ) (NNS QTLs )) (VP (VBP modulate ) (NP (NP (NN volume )) (CC and ) (NP (NN neuron ) (NN number)))))) )<a name="line.305"></a>
<FONT color="green">306</FONT>       * &lt;/PRE&gt;<a name="line.306"></a>
<FONT color="green">307</FONT>       * <a name="line.307"></a>
<FONT color="green">308</FONT>       * The start and end offsets of each TreebankNode will be aligned to the word offsets in the given<a name="line.308"></a>
<FONT color="green">309</FONT>       * text.<a name="line.309"></a>
<FONT color="green">310</FONT>       * <a name="line.310"></a>
<FONT color="green">311</FONT>       * @param parse<a name="line.311"></a>
<FONT color="green">312</FONT>       *          A TreeBank formatted parse<a name="line.312"></a>
<FONT color="green">313</FONT>       * @param text<a name="line.313"></a>
<FONT color="green">314</FONT>       *          The text to which the parse should be aligned<a name="line.314"></a>
<FONT color="green">315</FONT>       * @param textOffset<a name="line.315"></a>
<FONT color="green">316</FONT>       *          The character offset at which the parse text should start to be aligned. For example,<a name="line.316"></a>
<FONT color="green">317</FONT>       *          if the words of the parse start right at the beginning of the text, the appropriate<a name="line.317"></a>
<FONT color="green">318</FONT>       *          textOffset is 0.<a name="line.318"></a>
<FONT color="green">319</FONT>       * @return The TreebankNode root of the parse tree. The root node will be a TopTreebankNode, and<a name="line.319"></a>
<FONT color="green">320</FONT>       *         all its descendants will be TreebankNodes.<a name="line.320"></a>
<FONT color="green">321</FONT>       * @see TopTreebankNode<a name="line.321"></a>
<FONT color="green">322</FONT>       * @see TreebankNode<a name="line.322"></a>
<FONT color="green">323</FONT>       */<a name="line.323"></a>
<FONT color="green">324</FONT>      public static TopTreebankNode parse(String parse, String text, int textOffset) {<a name="line.324"></a>
<FONT color="green">325</FONT>        try {<a name="line.325"></a>
<FONT color="green">326</FONT>          TopTreebankNode topNode = new TopTreebankNode();<a name="line.326"></a>
<FONT color="green">327</FONT>          parse = prepareString(parse);<a name="line.327"></a>
<FONT color="green">328</FONT>          // used to capture the plain text of the sentence.<a name="line.328"></a>
<FONT color="green">329</FONT>          StringBuffer consumedText = new StringBuffer();<a name="line.329"></a>
<FONT color="green">330</FONT>          if (text != null) {<a name="line.330"></a>
<FONT color="green">331</FONT>            textOffset = movePastWhiteSpaceChars(text, textOffset);<a name="line.331"></a>
<FONT color="green">332</FONT>            consumedText.append(text.substring(0, textOffset));<a name="line.332"></a>
<FONT color="green">333</FONT>          }<a name="line.333"></a>
<FONT color="green">334</FONT>    <a name="line.334"></a>
<FONT color="green">335</FONT>          Stack&lt;Integer&gt; parseOffsetStack = new Stack&lt;Integer&gt;();<a name="line.335"></a>
<FONT color="green">336</FONT>          Stack&lt;Integer&gt; plainTextOffsetStack = new Stack&lt;Integer&gt;();<a name="line.336"></a>
<FONT color="green">337</FONT>    <a name="line.337"></a>
<FONT color="green">338</FONT>          // keeps the nodes that are waiting for their parents to be completed.<a name="line.338"></a>
<FONT color="green">339</FONT>          Stack&lt;TreebankNode&gt; parseStack = new Stack&lt;TreebankNode&gt;();<a name="line.339"></a>
<FONT color="green">340</FONT>    <a name="line.340"></a>
<FONT color="green">341</FONT>          for (int ci = 0; ci &lt; parse.length(); ci++) {<a name="line.341"></a>
<FONT color="green">342</FONT>            char c = parse.charAt(ci);<a name="line.342"></a>
<FONT color="green">343</FONT>            if (c == '(') {<a name="line.343"></a>
<FONT color="green">344</FONT>              // at the start of each constituent we will push the starting<a name="line.344"></a>
<FONT color="green">345</FONT>              // index of it<a name="line.345"></a>
<FONT color="green">346</FONT>              // w.r.t. the parse string.<a name="line.346"></a>
<FONT color="green">347</FONT>              parseOffsetStack.push(ci);<a name="line.347"></a>
<FONT color="green">348</FONT>              // also push the starting index w.r.t. the plain text of the<a name="line.348"></a>
<FONT color="green">349</FONT>              // sentence.<a name="line.349"></a>
<FONT color="green">350</FONT>              plainTextOffsetStack.push(consumedText.length());<a name="line.350"></a>
<FONT color="green">351</FONT>            } else if (c == ')') {<a name="line.351"></a>
<FONT color="green">352</FONT>              int begin = parseOffsetStack.pop();<a name="line.352"></a>
<FONT color="green">353</FONT>              int end = ci;<a name="line.353"></a>
<FONT color="green">354</FONT>              // the portion of the parse string that corresponds to the<a name="line.354"></a>
<FONT color="green">355</FONT>              // constituent that<a name="line.355"></a>
<FONT color="green">356</FONT>              // we found the left bracket for ')'.<a name="line.356"></a>
<FONT color="green">357</FONT>              String subParse = parse.substring(begin, end + 1);<a name="line.357"></a>
<FONT color="green">358</FONT>    <a name="line.358"></a>
<FONT color="green">359</FONT>              int textBegin = plainTextOffsetStack.pop();<a name="line.359"></a>
<FONT color="green">360</FONT>    <a name="line.360"></a>
<FONT color="green">361</FONT>              TreebankNode node = getLeafNode(subParse);<a name="line.361"></a>
<FONT color="green">362</FONT>              if (node != null) {<a name="line.362"></a>
<FONT color="green">363</FONT>                node.setTopNode(topNode);<a name="line.363"></a>
<FONT color="green">364</FONT>                node.setParseBegin(begin);<a name="line.364"></a>
<FONT color="green">365</FONT>                node.setParseEnd(end + 1);<a name="line.365"></a>
<FONT color="green">366</FONT>                String token = node.getText();<a name="line.366"></a>
<FONT color="green">367</FONT>    <a name="line.367"></a>
<FONT color="green">368</FONT>                if (token.length() &gt; 0) {<a name="line.368"></a>
<FONT color="green">369</FONT>                  int realBegin = movePastWhiteSpaceChars(text, textBegin);<a name="line.369"></a>
<FONT color="green">370</FONT>                  consumedText.append(text.substring(textBegin, realBegin));<a name="line.370"></a>
<FONT color="green">371</FONT>                  consumedText.append(token);<a name="line.371"></a>
<FONT color="green">372</FONT>                  node.setTextBegin(realBegin);<a name="line.372"></a>
<FONT color="green">373</FONT>                  node.setTextEnd(realBegin + token.length());<a name="line.373"></a>
<FONT color="green">374</FONT>    <a name="line.374"></a>
<FONT color="green">375</FONT>                } else {<a name="line.375"></a>
<FONT color="green">376</FONT>                  node.setTextBegin(textBegin);<a name="line.376"></a>
<FONT color="green">377</FONT>                  node.setTextEnd(textBegin + token.length());<a name="line.377"></a>
<FONT color="green">378</FONT>                }<a name="line.378"></a>
<FONT color="green">379</FONT>                checkText(node, text);<a name="line.379"></a>
<FONT color="green">380</FONT>                parseStack.push(node);<a name="line.380"></a>
<FONT color="green">381</FONT>              } else {<a name="line.381"></a>
<FONT color="green">382</FONT>                if (parse.lastIndexOf(')') == ci) // the last ')' is the top<a name="line.382"></a>
<FONT color="green">383</FONT>                  // node.<a name="line.383"></a>
<FONT color="green">384</FONT>                  node = topNode; // this is the instance that will be<a name="line.384"></a>
<FONT color="green">385</FONT>                // returned.<a name="line.385"></a>
<FONT color="green">386</FONT>                else<a name="line.386"></a>
<FONT color="green">387</FONT>                  node = new TreebankNode();<a name="line.387"></a>
<FONT color="green">388</FONT>                node.setTopNode(topNode);<a name="line.388"></a>
<FONT color="green">389</FONT>                node.setParseBegin(begin);<a name="line.389"></a>
<FONT color="green">390</FONT>                node.setParseEnd(end + 1);<a name="line.390"></a>
<FONT color="green">391</FONT>                String type = getType(subParse);<a name="line.391"></a>
<FONT color="green">392</FONT>                node.setType(getTypeFromType(type));<a name="line.392"></a>
<FONT color="green">393</FONT>                node.setTags(getTagsFromType(type));<a name="line.393"></a>
<FONT color="green">394</FONT>                node.setLeaf(false);<a name="line.394"></a>
<FONT color="green">395</FONT>                // keep adding the nodes on the stack until it is empty or<a name="line.395"></a>
<FONT color="green">396</FONT>                // the next node on the stack starts before the current node<a name="line.396"></a>
<FONT color="green">397</FONT>                // (i.e. has a different<a name="line.397"></a>
<FONT color="green">398</FONT>                // parent than the current node that will be completed<a name="line.398"></a>
<FONT color="green">399</FONT>                // later.)<a name="line.399"></a>
<FONT color="green">400</FONT>                while (parseStack.size() &gt; 0<a name="line.400"></a>
<FONT color="green">401</FONT>                    &amp;&amp; parseStack.peek().getParseBegin() &gt; node.getParseBegin()) {<a name="line.401"></a>
<FONT color="green">402</FONT>                  TreebankNode child = parseStack.pop();<a name="line.402"></a>
<FONT color="green">403</FONT>                  node.addChild(child);<a name="line.403"></a>
<FONT color="green">404</FONT>                  child.setParent(node);<a name="line.404"></a>
<FONT color="green">405</FONT>                }<a name="line.405"></a>
<FONT color="green">406</FONT>                // we typically add a token followed by a space to<a name="line.406"></a>
<FONT color="green">407</FONT>                // plainText, except when the<a name="line.407"></a>
<FONT color="green">408</FONT>                // token is an empty string as it is when the corresponding<a name="line.408"></a>
<FONT color="green">409</FONT>                // type is -NONE-<a name="line.409"></a>
<FONT color="green">410</FONT>                int realBegin = movePastWhiteSpaceChars(text, textBegin);<a name="line.410"></a>
<FONT color="green">411</FONT>                node.setTextBegin(realBegin);<a name="line.411"></a>
<FONT color="green">412</FONT>                node.setTextEnd(Math.max(realBegin, consumedText.length()));<a name="line.412"></a>
<FONT color="green">413</FONT>    <a name="line.413"></a>
<FONT color="green">414</FONT>                try {<a name="line.414"></a>
<FONT color="green">415</FONT>                  node.setText(consumedText.substring(node.getTextBegin(), node.getTextEnd()));<a name="line.415"></a>
<FONT color="green">416</FONT>                } catch (StringIndexOutOfBoundsException sioobe) {<a name="line.416"></a>
<FONT color="green">417</FONT>                  node.setText("");<a name="line.417"></a>
<FONT color="green">418</FONT>                }<a name="line.418"></a>
<FONT color="green">419</FONT>                checkText(node, text);<a name="line.419"></a>
<FONT color="green">420</FONT>                parseStack.push(node);<a name="line.420"></a>
<FONT color="green">421</FONT>              }<a name="line.421"></a>
<FONT color="green">422</FONT>            }<a name="line.422"></a>
<FONT color="green">423</FONT>          }<a name="line.423"></a>
<FONT color="green">424</FONT>    <a name="line.424"></a>
<FONT color="green">425</FONT>          topNode.setTreebankParse(parse);<a name="line.425"></a>
<FONT color="green">426</FONT>          topNode.initTerminalNodes();<a name="line.426"></a>
<FONT color="green">427</FONT>          return topNode;<a name="line.427"></a>
<FONT color="green">428</FONT>        } catch (RuntimeException e) {<a name="line.428"></a>
<FONT color="green">429</FONT>          throw new IllegalArgumentException("exception thrown when parsing the following: " + parse, e);<a name="line.429"></a>
<FONT color="green">430</FONT>        }<a name="line.430"></a>
<FONT color="green">431</FONT>      }<a name="line.431"></a>
<FONT color="green">432</FONT>    <a name="line.432"></a>
<FONT color="green">433</FONT>      private static final Pattern nonwhiteSpaceCharPattern = Pattern.compile("[^\\s]");<a name="line.433"></a>
<FONT color="green">434</FONT>    <a name="line.434"></a>
<FONT color="green">435</FONT>      public static int movePastWhiteSpaceChars(String text, int textOffset) {<a name="line.435"></a>
<FONT color="green">436</FONT>        Matcher matcher = nonwhiteSpaceCharPattern.matcher(text);<a name="line.436"></a>
<FONT color="green">437</FONT>        if (matcher.find(textOffset)) {<a name="line.437"></a>
<FONT color="green">438</FONT>          return matcher.start();<a name="line.438"></a>
<FONT color="green">439</FONT>        }<a name="line.439"></a>
<FONT color="green">440</FONT>        return textOffset;<a name="line.440"></a>
<FONT color="green">441</FONT>      }<a name="line.441"></a>
<FONT color="green">442</FONT>    <a name="line.442"></a>
<FONT color="green">443</FONT>      /**<a name="line.443"></a>
<FONT color="green">444</FONT>       * Replace specially encoded tokens with their original textual representation.<a name="line.444"></a>
<FONT color="green">445</FONT>       * (http://www.cis.upenn.edu/~treebank/tokenization.html)<a name="line.445"></a>
<FONT color="green">446</FONT>       * <a name="line.446"></a>
<FONT color="green">447</FONT>       * @param value<a name="line.447"></a>
<FONT color="green">448</FONT>       * @param type<a name="line.448"></a>
<FONT color="green">449</FONT>       * @return The string in its original textual representation.<a name="line.449"></a>
<FONT color="green">450</FONT>       */<a name="line.450"></a>
<FONT color="green">451</FONT>      private static String getToken(String value, String type) {<a name="line.451"></a>
<FONT color="green">452</FONT>        value = value.replace("-RCB-", "}");<a name="line.452"></a>
<FONT color="green">453</FONT>        value = value.replace("-LCB-", "{");<a name="line.453"></a>
<FONT color="green">454</FONT>        value = value.replace("-RRB-", ")");<a name="line.454"></a>
<FONT color="green">455</FONT>        value = value.replace("-LRB-", "(");<a name="line.455"></a>
<FONT color="green">456</FONT>        value = value.replace("-RSB-", "]");<a name="line.456"></a>
<FONT color="green">457</FONT>        value = value.replace("-LSB-", "[");<a name="line.457"></a>
<FONT color="green">458</FONT>        value = value.replace("``", "\"");<a name="line.458"></a>
<FONT color="green">459</FONT>        value = value.replace("''", "\"");<a name="line.459"></a>
<FONT color="green">460</FONT>    <a name="line.460"></a>
<FONT color="green">461</FONT>        if (type.equals("-NONE-"))<a name="line.461"></a>
<FONT color="green">462</FONT>          return "";<a name="line.462"></a>
<FONT color="green">463</FONT>    <a name="line.463"></a>
<FONT color="green">464</FONT>        if (value.contains("\\/"))<a name="line.464"></a>
<FONT color="green">465</FONT>          return value.replace("\\/", "/");<a name="line.465"></a>
<FONT color="green">466</FONT>    <a name="line.466"></a>
<FONT color="green">467</FONT>        return value;<a name="line.467"></a>
<FONT color="green">468</FONT>      }<a name="line.468"></a>
<FONT color="green">469</FONT>    <a name="line.469"></a>
<FONT color="green">470</FONT>      /**<a name="line.470"></a>
<FONT color="green">471</FONT>       * Generally speaking, we expect one treebanked sentence per line. This method will simply return<a name="line.471"></a>
<FONT color="green">472</FONT>       * the lines of a document assuming that each line has matching parentheses. However, the native<a name="line.472"></a>
<FONT color="green">473</FONT>       * penn treebank data contains parsed sentences that are broken up across multiple lines. Each<a name="line.473"></a>
<FONT color="green">474</FONT>       * sentence in the PTB starts with "( (S..." and so we split on this to get the sentences. If this<a name="line.474"></a>
<FONT color="green">475</FONT>       * method sees "( (S...", then it will return the contents split on that pattern. If not, it will<a name="line.475"></a>
<FONT color="green">476</FONT>       * return the lines of the input string.<a name="line.476"></a>
<FONT color="green">477</FONT>       * <a name="line.477"></a>
<FONT color="green">478</FONT>       * Splits an .mrg file (e.g. wsj/mrg/00/wsj_0020.mrg) into sentence parses.<a name="line.478"></a>
<FONT color="green">479</FONT>       * <a name="line.479"></a>
<FONT color="green">480</FONT>       * @param mrgContents<a name="line.480"></a>
<FONT color="green">481</FONT>       * @return individual sentence parses from treebank - i.e. strings of the form "( (S..."<a name="line.481"></a>
<FONT color="green">482</FONT>       */<a name="line.482"></a>
<FONT color="green">483</FONT>    <a name="line.483"></a>
<FONT color="green">484</FONT>      public static String[] splitSentences(String mrgContents) {<a name="line.484"></a>
<FONT color="green">485</FONT>        // Splitting on this regular expression can cause the first value<a name="line.485"></a>
<FONT color="green">486</FONT>        // in the array to be an empty string if e.g. the first line of the file<a name="line.486"></a>
<FONT color="green">487</FONT>        // is blank<a name="line.487"></a>
<FONT color="green">488</FONT>        String[] contents = mrgContents.split("(?=\\(\\s*\\()");<a name="line.488"></a>
<FONT color="green">489</FONT>        if (contents.length &gt; 1) {<a name="line.489"></a>
<FONT color="green">490</FONT>          if (contents.length &gt; 0 &amp;&amp; contents[0].trim().equals("")) {<a name="line.490"></a>
<FONT color="green">491</FONT>            String[] returnValues = new String[contents.length - 1];<a name="line.491"></a>
<FONT color="green">492</FONT>            System.arraycopy(contents, 1, returnValues, 0, returnValues.length);<a name="line.492"></a>
<FONT color="green">493</FONT>            return returnValues;<a name="line.493"></a>
<FONT color="green">494</FONT>          } else {<a name="line.494"></a>
<FONT color="green">495</FONT>            String[] returnValues = new String[contents.length];<a name="line.495"></a>
<FONT color="green">496</FONT>            System.arraycopy(contents, 0, returnValues, 0, returnValues.length);<a name="line.496"></a>
<FONT color="green">497</FONT>            return returnValues;<a name="line.497"></a>
<FONT color="green">498</FONT>          }<a name="line.498"></a>
<FONT color="green">499</FONT>        }<a name="line.499"></a>
<FONT color="green">500</FONT>    <a name="line.500"></a>
<FONT color="green">501</FONT>        String[] lines = mrgContents.split("\r?\n");<a name="line.501"></a>
<FONT color="green">502</FONT>        for (String line : lines) {<a name="line.502"></a>
<FONT color="green">503</FONT>          if (!parensMatch(line)) {<a name="line.503"></a>
<FONT color="green">504</FONT>            throw new IllegalArgumentException(<a name="line.504"></a>
<FONT color="green">505</FONT>                "Parentheses counts do not match for treebank sentence: " + line);<a name="line.505"></a>
<FONT color="green">506</FONT>          }<a name="line.506"></a>
<FONT color="green">507</FONT>        }<a name="line.507"></a>
<FONT color="green">508</FONT>        return lines;<a name="line.508"></a>
<FONT color="green">509</FONT>      }<a name="line.509"></a>
<FONT color="green">510</FONT>    <a name="line.510"></a>
<FONT color="green">511</FONT>      public static boolean parensMatch(String contents) {<a name="line.511"></a>
<FONT color="green">512</FONT>        int leftParenCount = 0;<a name="line.512"></a>
<FONT color="green">513</FONT>        int rightParenCount = 0;<a name="line.513"></a>
<FONT color="green">514</FONT>    <a name="line.514"></a>
<FONT color="green">515</FONT>        for (char c : contents.toCharArray()) {<a name="line.515"></a>
<FONT color="green">516</FONT>          if (c == '(')<a name="line.516"></a>
<FONT color="green">517</FONT>            leftParenCount++;<a name="line.517"></a>
<FONT color="green">518</FONT>          if (c == ')')<a name="line.518"></a>
<FONT color="green">519</FONT>            rightParenCount++;<a name="line.519"></a>
<FONT color="green">520</FONT>        }<a name="line.520"></a>
<FONT color="green">521</FONT>    <a name="line.521"></a>
<FONT color="green">522</FONT>        return leftParenCount == rightParenCount;<a name="line.522"></a>
<FONT color="green">523</FONT>    <a name="line.523"></a>
<FONT color="green">524</FONT>      }<a name="line.524"></a>
<FONT color="green">525</FONT>    <a name="line.525"></a>
<FONT color="green">526</FONT>      /**<a name="line.526"></a>
<FONT color="green">527</FONT>       * This method parses an entire documents worth of treebanked sentences.<a name="line.527"></a>
<FONT color="green">528</FONT>       * <a name="line.528"></a>
<FONT color="green">529</FONT>       * @param parse<a name="line.529"></a>
<FONT color="green">530</FONT>       * @param textOffset<a name="line.530"></a>
<FONT color="green">531</FONT>       *          a value that corresponds to the character offset of the first character of the<a name="line.531"></a>
<FONT color="green">532</FONT>       *          document. The appropriate value for this method will typically be 0.<a name="line.532"></a>
<FONT color="green">533</FONT>       * @param text<a name="line.533"></a>
<FONT color="green">534</FONT>       *          a single document provided as plain text. If you do not have access to the original<a name="line.534"></a>
<FONT color="green">535</FONT>       *          plain text of the document, you can generate some using<a name="line.535"></a>
<FONT color="green">536</FONT>       *          {@link #inferPlainText(String)}.<a name="line.536"></a>
<FONT color="green">537</FONT>       */<a name="line.537"></a>
<FONT color="green">538</FONT>      public static List&lt;TopTreebankNode&gt; parseDocument(String parse, int textOffset, String text) {<a name="line.538"></a>
<FONT color="green">539</FONT>        List&lt;TopTreebankNode&gt; returnValues = new ArrayList&lt;TopTreebankNode&gt;();<a name="line.539"></a>
<FONT color="green">540</FONT>        String[] sentenceParses = splitSentences(parse);<a name="line.540"></a>
<FONT color="green">541</FONT>    <a name="line.541"></a>
<FONT color="green">542</FONT>        for (String sentenceParse : sentenceParses) {<a name="line.542"></a>
<FONT color="green">543</FONT>          TopTreebankNode topNode = parse(sentenceParse, text, textOffset);<a name="line.543"></a>
<FONT color="green">544</FONT>          textOffset = topNode.getTextEnd();<a name="line.544"></a>
<FONT color="green">545</FONT>          returnValues.add(topNode);<a name="line.545"></a>
<FONT color="green">546</FONT>        }<a name="line.546"></a>
<FONT color="green">547</FONT>        return returnValues;<a name="line.547"></a>
<FONT color="green">548</FONT>      }<a name="line.548"></a>
<FONT color="green">549</FONT>    <a name="line.549"></a>
<FONT color="green">550</FONT>    }<a name="line.550"></a>




























































</PRE>
</BODY>
</HTML>
