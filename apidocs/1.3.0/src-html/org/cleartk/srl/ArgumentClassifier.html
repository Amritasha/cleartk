<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/** <a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2007-2008, Regents of the University of Colorado <a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved.<a name="line.3"></a>
<span class="sourceLineNo">004</span> * <a name="line.4"></a>
<span class="sourceLineNo">005</span> * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<span class="sourceLineNo">006</span> * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<span class="sourceLineNo">007</span> * <a name="line.7"></a>
<span class="sourceLineNo">008</span> * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<span class="sourceLineNo">009</span> * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<span class="sourceLineNo">010</span> * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<span class="sourceLineNo">011</span> * <a name="line.11"></a>
<span class="sourceLineNo">012</span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<span class="sourceLineNo">013</span> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<span class="sourceLineNo">014</span> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<span class="sourceLineNo">015</span> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<span class="sourceLineNo">016</span> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<span class="sourceLineNo">017</span> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<span class="sourceLineNo">018</span> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<span class="sourceLineNo">019</span> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<span class="sourceLineNo">020</span> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<span class="sourceLineNo">021</span> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<span class="sourceLineNo">022</span> * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<span class="sourceLineNo">023</span> */<a name="line.23"></a>
<span class="sourceLineNo">024</span>package org.cleartk.srl;<a name="line.24"></a>
<span class="sourceLineNo">025</span><a name="line.25"></a>
<span class="sourceLineNo">026</span>import java.io.File;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import java.util.ArrayList;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import java.util.Collection;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import java.util.HashMap;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import java.util.List;<a name="line.30"></a>
<span class="sourceLineNo">031</span>import java.util.Map;<a name="line.31"></a>
<span class="sourceLineNo">032</span>import java.util.logging.Logger;<a name="line.32"></a>
<span class="sourceLineNo">033</span><a name="line.33"></a>
<span class="sourceLineNo">034</span>import org.apache.uima.UimaContext;<a name="line.34"></a>
<span class="sourceLineNo">035</span>import org.apache.uima.analysis_engine.AnalysisEngineDescription;<a name="line.35"></a>
<span class="sourceLineNo">036</span>import org.apache.uima.analysis_engine.AnalysisEngineProcessException;<a name="line.36"></a>
<span class="sourceLineNo">037</span>import org.apache.uima.jcas.JCas;<a name="line.37"></a>
<span class="sourceLineNo">038</span>import org.apache.uima.resource.ResourceInitializationException;<a name="line.38"></a>
<span class="sourceLineNo">039</span>import org.cleartk.classifier.CleartkAnnotator;<a name="line.39"></a>
<span class="sourceLineNo">040</span>import org.cleartk.classifier.DataWriterFactory;<a name="line.40"></a>
<span class="sourceLineNo">041</span>import org.cleartk.classifier.Feature;<a name="line.41"></a>
<span class="sourceLineNo">042</span>import org.cleartk.classifier.Instance;<a name="line.42"></a>
<span class="sourceLineNo">043</span>import org.cleartk.classifier.feature.extractor.CleartkExtractor;<a name="line.43"></a>
<span class="sourceLineNo">044</span>import org.cleartk.classifier.feature.extractor.CleartkExtractor.FirstCovered;<a name="line.44"></a>
<span class="sourceLineNo">045</span>import org.cleartk.classifier.feature.extractor.CleartkExtractor.LastCovered;<a name="line.45"></a>
<span class="sourceLineNo">046</span>import org.cleartk.classifier.feature.extractor.CleartkExtractorException;<a name="line.46"></a>
<span class="sourceLineNo">047</span>import org.cleartk.classifier.feature.extractor.annotationpair.AnnotationPairFeatureExtractor;<a name="line.47"></a>
<span class="sourceLineNo">048</span>import org.cleartk.classifier.feature.extractor.annotationpair.MatchingAnnotationPairExtractor;<a name="line.48"></a>
<span class="sourceLineNo">049</span>import org.cleartk.classifier.feature.extractor.annotationpair.NamingAnnotationPairFeatureExtractor;<a name="line.49"></a>
<span class="sourceLineNo">050</span>import org.cleartk.classifier.feature.extractor.annotationpair.RelativePositionExtractor;<a name="line.50"></a>
<span class="sourceLineNo">051</span>import org.cleartk.classifier.feature.extractor.simple.CombinedExtractor;<a name="line.51"></a>
<span class="sourceLineNo">052</span>import org.cleartk.classifier.feature.extractor.simple.CoveredTextExtractor;<a name="line.52"></a>
<span class="sourceLineNo">053</span>import org.cleartk.classifier.feature.extractor.simple.MatchingAnnotationExtractor;<a name="line.53"></a>
<span class="sourceLineNo">054</span>import org.cleartk.classifier.feature.extractor.simple.NamingExtractor;<a name="line.54"></a>
<span class="sourceLineNo">055</span>import org.cleartk.classifier.feature.extractor.simple.SimpleFeatureExtractor;<a name="line.55"></a>
<span class="sourceLineNo">056</span>import org.cleartk.classifier.jar.DirectoryDataWriterFactory;<a name="line.56"></a>
<span class="sourceLineNo">057</span>import org.cleartk.classifier.jar.GenericJarClassifierFactory;<a name="line.57"></a>
<span class="sourceLineNo">058</span>import org.cleartk.srl.feature.NamedEntityExtractor;<a name="line.58"></a>
<span class="sourceLineNo">059</span>import org.cleartk.srl.feature.NodeTypeExtractor;<a name="line.59"></a>
<span class="sourceLineNo">060</span>import org.cleartk.srl.feature.POSExtractor;<a name="line.60"></a>
<span class="sourceLineNo">061</span>import org.cleartk.srl.feature.StemExtractor;<a name="line.61"></a>
<span class="sourceLineNo">062</span>import org.cleartk.srl.type.Predicate;<a name="line.62"></a>
<span class="sourceLineNo">063</span>import org.cleartk.srl.type.SemanticArgument;<a name="line.63"></a>
<span class="sourceLineNo">064</span>import org.cleartk.syntax.constituent.type.TopTreebankNode;<a name="line.64"></a>
<span class="sourceLineNo">065</span>import org.cleartk.syntax.constituent.type.TreebankNode;<a name="line.65"></a>
<span class="sourceLineNo">066</span>import org.cleartk.syntax.feature.HeadWordExtractor;<a name="line.66"></a>
<span class="sourceLineNo">067</span>import org.cleartk.syntax.feature.ParentExtractor;<a name="line.67"></a>
<span class="sourceLineNo">068</span>import org.cleartk.syntax.feature.SiblingExtractor;<a name="line.68"></a>
<span class="sourceLineNo">069</span>import org.cleartk.syntax.feature.SubCategorizationExtractor;<a name="line.69"></a>
<span class="sourceLineNo">070</span>import org.cleartk.syntax.feature.SyntacticPathExtractor;<a name="line.70"></a>
<span class="sourceLineNo">071</span>import org.cleartk.token.type.Sentence;<a name="line.71"></a>
<span class="sourceLineNo">072</span>import org.cleartk.token.type.Token;<a name="line.72"></a>
<span class="sourceLineNo">073</span>import org.cleartk.util.AnnotationUtil;<a name="line.73"></a>
<span class="sourceLineNo">074</span>import org.cleartk.util.UIMAUtil;<a name="line.74"></a>
<span class="sourceLineNo">075</span>import org.uimafit.factory.AnalysisEngineFactory;<a name="line.75"></a>
<span class="sourceLineNo">076</span>import org.uimafit.util.JCasUtil;<a name="line.76"></a>
<span class="sourceLineNo">077</span><a name="line.77"></a>
<span class="sourceLineNo">078</span>/**<a name="line.78"></a>
<span class="sourceLineNo">079</span> * &lt;br&gt;<a name="line.79"></a>
<span class="sourceLineNo">080</span> * Copyright (c) 2007-2008, Regents of the University of Colorado &lt;br&gt;<a name="line.80"></a>
<span class="sourceLineNo">081</span> * All rights reserved.<a name="line.81"></a>
<span class="sourceLineNo">082</span> * <a name="line.82"></a>
<span class="sourceLineNo">083</span> * <a name="line.83"></a>
<span class="sourceLineNo">084</span> * @author Philipp Wetzler<a name="line.84"></a>
<span class="sourceLineNo">085</span> */<a name="line.85"></a>
<span class="sourceLineNo">086</span><a name="line.86"></a>
<span class="sourceLineNo">087</span>public class ArgumentClassifier extends CleartkAnnotator&lt;String&gt; {<a name="line.87"></a>
<span class="sourceLineNo">088</span><a name="line.88"></a>
<span class="sourceLineNo">089</span>  public static AnalysisEngineDescription getWriterDescription(<a name="line.89"></a>
<span class="sourceLineNo">090</span>      Class&lt;? extends DataWriterFactory&lt;String&gt;&gt; dataWriterFactoryClass,<a name="line.90"></a>
<span class="sourceLineNo">091</span>      File outputDirectory) throws ResourceInitializationException {<a name="line.91"></a>
<span class="sourceLineNo">092</span>    return AnalysisEngineFactory.createPrimitiveDescription(<a name="line.92"></a>
<span class="sourceLineNo">093</span>        ArgumentClassifier.class,<a name="line.93"></a>
<span class="sourceLineNo">094</span>        CleartkAnnotator.PARAM_DATA_WRITER_FACTORY_CLASS_NAME,<a name="line.94"></a>
<span class="sourceLineNo">095</span>        dataWriterFactoryClass.getName(),<a name="line.95"></a>
<span class="sourceLineNo">096</span>        DirectoryDataWriterFactory.PARAM_OUTPUT_DIRECTORY,<a name="line.96"></a>
<span class="sourceLineNo">097</span>        outputDirectory.toString());<a name="line.97"></a>
<span class="sourceLineNo">098</span>  }<a name="line.98"></a>
<span class="sourceLineNo">099</span><a name="line.99"></a>
<span class="sourceLineNo">100</span>  public static AnalysisEngineDescription getClassifierDescription(File classifierJar)<a name="line.100"></a>
<span class="sourceLineNo">101</span>      throws ResourceInitializationException {<a name="line.101"></a>
<span class="sourceLineNo">102</span>    return AnalysisEngineFactory.createPrimitiveDescription(<a name="line.102"></a>
<span class="sourceLineNo">103</span>        ArgumentClassifier.class,<a name="line.103"></a>
<span class="sourceLineNo">104</span>        GenericJarClassifierFactory.PARAM_CLASSIFIER_JAR_PATH,<a name="line.104"></a>
<span class="sourceLineNo">105</span>        classifierJar.toString());<a name="line.105"></a>
<span class="sourceLineNo">106</span>  }<a name="line.106"></a>
<span class="sourceLineNo">107</span><a name="line.107"></a>
<span class="sourceLineNo">108</span>  @Override<a name="line.108"></a>
<span class="sourceLineNo">109</span>  public void initialize(UimaContext context) throws ResourceInitializationException {<a name="line.109"></a>
<span class="sourceLineNo">110</span>    super.initialize(context);<a name="line.110"></a>
<span class="sourceLineNo">111</span><a name="line.111"></a>
<span class="sourceLineNo">112</span>    SimpleFeatureExtractor defaultTokenExtractorSet = new MatchingAnnotationExtractor(<a name="line.112"></a>
<span class="sourceLineNo">113</span>        Token.class,<a name="line.113"></a>
<span class="sourceLineNo">114</span>        new CoveredTextExtractor(),<a name="line.114"></a>
<span class="sourceLineNo">115</span>        new StemExtractor(),<a name="line.115"></a>
<span class="sourceLineNo">116</span>        new POSExtractor());<a name="line.116"></a>
<span class="sourceLineNo">117</span><a name="line.117"></a>
<span class="sourceLineNo">118</span>    SimpleFeatureExtractor defaultConstituentExtractorSet = new CombinedExtractor(<a name="line.118"></a>
<span class="sourceLineNo">119</span>        new NodeTypeExtractor(),<a name="line.119"></a>
<span class="sourceLineNo">120</span>        // new TypePathExtractor(TreebankNode.class, "nodeTags"),<a name="line.120"></a>
<span class="sourceLineNo">121</span>        new HeadWordExtractor(defaultTokenExtractorSet),<a name="line.121"></a>
<span class="sourceLineNo">122</span>        new CleartkExtractor(Token.class, defaultTokenExtractorSet, new FirstCovered(1)),<a name="line.122"></a>
<span class="sourceLineNo">123</span>        new CleartkExtractor(Token.class, defaultTokenExtractorSet, new LastCovered(1)));<a name="line.123"></a>
<span class="sourceLineNo">124</span><a name="line.124"></a>
<span class="sourceLineNo">125</span>    this.predicateExtractor = new NamingExtractor(<a name="line.125"></a>
<span class="sourceLineNo">126</span>        "Predicate",<a name="line.126"></a>
<span class="sourceLineNo">127</span>        defaultTokenExtractorSet,<a name="line.127"></a>
<span class="sourceLineNo">128</span>        new MatchingAnnotationExtractor(TreebankNode.class, new SubCategorizationExtractor()));<a name="line.128"></a>
<span class="sourceLineNo">129</span><a name="line.129"></a>
<span class="sourceLineNo">130</span>    this.constituentExtractor = new NamingExtractor("Constituent", new MatchingAnnotationExtractor(<a name="line.130"></a>
<span class="sourceLineNo">131</span>        TreebankNode.class,<a name="line.131"></a>
<span class="sourceLineNo">132</span>        defaultConstituentExtractorSet,<a name="line.132"></a>
<span class="sourceLineNo">133</span>        new ParentExtractor(defaultConstituentExtractorSet),<a name="line.133"></a>
<span class="sourceLineNo">134</span>        new SiblingExtractor(-1, defaultConstituentExtractorSet),<a name="line.134"></a>
<span class="sourceLineNo">135</span>        new SiblingExtractor(1, defaultConstituentExtractorSet),<a name="line.135"></a>
<span class="sourceLineNo">136</span>        new NamedEntityExtractor()));<a name="line.136"></a>
<span class="sourceLineNo">137</span><a name="line.137"></a>
<span class="sourceLineNo">138</span>    this.predicateAndConstituentExtractor = new NamingAnnotationPairFeatureExtractor(<a name="line.138"></a>
<span class="sourceLineNo">139</span>        "PredicateAndConstituent",<a name="line.139"></a>
<span class="sourceLineNo">140</span>        new MatchingAnnotationPairExtractor(<a name="line.140"></a>
<span class="sourceLineNo">141</span>            TreebankNode.class,<a name="line.141"></a>
<span class="sourceLineNo">142</span>            TreebankNode.class,<a name="line.142"></a>
<span class="sourceLineNo">143</span>            new SyntacticPathExtractor(new NodeTypeExtractor()),<a name="line.143"></a>
<span class="sourceLineNo">144</span>            new RelativePositionExtractor()));<a name="line.144"></a>
<span class="sourceLineNo">145</span><a name="line.145"></a>
<span class="sourceLineNo">146</span>  }<a name="line.146"></a>
<span class="sourceLineNo">147</span><a name="line.147"></a>
<span class="sourceLineNo">148</span>  @Override<a name="line.148"></a>
<span class="sourceLineNo">149</span>  public void process(JCas jCas) throws AnalysisEngineProcessException {<a name="line.149"></a>
<span class="sourceLineNo">150</span>    /*<a name="line.150"></a>
<span class="sourceLineNo">151</span>     * Iterate over sentences in document<a name="line.151"></a>
<span class="sourceLineNo">152</span>     */<a name="line.152"></a>
<span class="sourceLineNo">153</span>    Collection&lt;Sentence&gt; sentences = JCasUtil.select(jCas, Sentence.class);<a name="line.153"></a>
<span class="sourceLineNo">154</span><a name="line.154"></a>
<span class="sourceLineNo">155</span>    nSentences = 0;<a name="line.155"></a>
<span class="sourceLineNo">156</span>    nPredicates = 0;<a name="line.156"></a>
<span class="sourceLineNo">157</span>    nArguments = 0;<a name="line.157"></a>
<span class="sourceLineNo">158</span><a name="line.158"></a>
<span class="sourceLineNo">159</span>    for (Sentence sentence : sentences) {<a name="line.159"></a>
<span class="sourceLineNo">160</span>      processSentence(jCas, sentence);<a name="line.160"></a>
<span class="sourceLineNo">161</span>    }<a name="line.161"></a>
<span class="sourceLineNo">162</span><a name="line.162"></a>
<span class="sourceLineNo">163</span>    logger.info(String.format(<a name="line.163"></a>
<span class="sourceLineNo">164</span>        "processed %d sentences, %d predicates, ~%d arguments per predicate",<a name="line.164"></a>
<span class="sourceLineNo">165</span>        nSentences,<a name="line.165"></a>
<span class="sourceLineNo">166</span>        nPredicates,<a name="line.166"></a>
<span class="sourceLineNo">167</span>        nPredicates == 0 ? 0 : nArguments / nPredicates));<a name="line.167"></a>
<span class="sourceLineNo">168</span>  }<a name="line.168"></a>
<span class="sourceLineNo">169</span><a name="line.169"></a>
<span class="sourceLineNo">170</span>  void processSentence(JCas jCas, Sentence sentence) throws AnalysisEngineProcessException {<a name="line.170"></a>
<span class="sourceLineNo">171</span>    nSentences += 1;<a name="line.171"></a>
<span class="sourceLineNo">172</span><a name="line.172"></a>
<span class="sourceLineNo">173</span>    if (sentence.getCoveredText().length() &gt; 40)<a name="line.173"></a>
<span class="sourceLineNo">174</span>      logger.fine(String.format(<a name="line.174"></a>
<span class="sourceLineNo">175</span>          "process sentence \"%s ...\"",<a name="line.175"></a>
<span class="sourceLineNo">176</span>          sentence.getCoveredText().substring(0, 39)));<a name="line.176"></a>
<span class="sourceLineNo">177</span>    else<a name="line.177"></a>
<span class="sourceLineNo">178</span>      logger.fine(String.format("process sentence \"%s\"", sentence.getCoveredText()));<a name="line.178"></a>
<span class="sourceLineNo">179</span><a name="line.179"></a>
<span class="sourceLineNo">180</span>    /*<a name="line.180"></a>
<span class="sourceLineNo">181</span>     * Pre-compute sentence level data: sentenceConstituents: list of all constituents in sentence<a name="line.181"></a>
<span class="sourceLineNo">182</span>     */<a name="line.182"></a>
<span class="sourceLineNo">183</span>    TopTreebankNode top = AnnotationUtil.selectFirstMatching(jCas, TopTreebankNode.class, sentence);<a name="line.183"></a>
<span class="sourceLineNo">184</span>    if (top == null) {<a name="line.184"></a>
<span class="sourceLineNo">185</span>      throw CleartkExtractorException.noAnnotationInWindow(TopTreebankNode.class, sentence);<a name="line.185"></a>
<span class="sourceLineNo">186</span>    }<a name="line.186"></a>
<span class="sourceLineNo">187</span>    List&lt;TreebankNode&gt; constituents = new ArrayList&lt;TreebankNode&gt;(200);<a name="line.187"></a>
<span class="sourceLineNo">188</span>    collectConstituents(top, constituents);<a name="line.188"></a>
<span class="sourceLineNo">189</span><a name="line.189"></a>
<span class="sourceLineNo">190</span>    /*<a name="line.190"></a>
<span class="sourceLineNo">191</span>     * Compute constituent features for all constituents in sentence<a name="line.191"></a>
<span class="sourceLineNo">192</span>     */<a name="line.192"></a>
<span class="sourceLineNo">193</span>    Map&lt;TreebankNode, List&lt;Feature&gt;&gt; constituentFeatures = new HashMap&lt;TreebankNode, List&lt;Feature&gt;&gt;();<a name="line.193"></a>
<span class="sourceLineNo">194</span>    for (TreebankNode c : constituents) {<a name="line.194"></a>
<span class="sourceLineNo">195</span>      List&lt;Feature&gt; features = constituentExtractor.extract(jCas, c);<a name="line.195"></a>
<span class="sourceLineNo">196</span>      constituentFeatures.put(c, features);<a name="line.196"></a>
<span class="sourceLineNo">197</span>    }<a name="line.197"></a>
<span class="sourceLineNo">198</span><a name="line.198"></a>
<span class="sourceLineNo">199</span>    /*<a name="line.199"></a>
<span class="sourceLineNo">200</span>     * Iterate over predicates in sentence<a name="line.200"></a>
<span class="sourceLineNo">201</span>     */<a name="line.201"></a>
<span class="sourceLineNo">202</span>    List&lt;Predicate&gt; predicates = JCasUtil.selectCovered(jCas, Predicate.class, sentence);<a name="line.202"></a>
<span class="sourceLineNo">203</span>    for (Predicate predicate : predicates) {<a name="line.203"></a>
<span class="sourceLineNo">204</span>      processPredicate(jCas, predicate, constituentFeatures);<a name="line.204"></a>
<span class="sourceLineNo">205</span>    }<a name="line.205"></a>
<span class="sourceLineNo">206</span>  }<a name="line.206"></a>
<span class="sourceLineNo">207</span><a name="line.207"></a>
<span class="sourceLineNo">208</span>  public void processPredicate(<a name="line.208"></a>
<span class="sourceLineNo">209</span>      JCas jCas,<a name="line.209"></a>
<span class="sourceLineNo">210</span>      Predicate predicate,<a name="line.210"></a>
<span class="sourceLineNo">211</span>      Map&lt;TreebankNode, List&lt;Feature&gt;&gt; sentenceConstituentFeatures)<a name="line.211"></a>
<span class="sourceLineNo">212</span>      throws AnalysisEngineProcessException {<a name="line.212"></a>
<span class="sourceLineNo">213</span>    nPredicates += 1;<a name="line.213"></a>
<span class="sourceLineNo">214</span><a name="line.214"></a>
<span class="sourceLineNo">215</span>    /*<a name="line.215"></a>
<span class="sourceLineNo">216</span>     * Compute predicate features<a name="line.216"></a>
<span class="sourceLineNo">217</span>     */<a name="line.217"></a>
<span class="sourceLineNo">218</span>    List&lt;Feature&gt; predicateFeatures = new ArrayList&lt;Feature&gt;(12);<a name="line.218"></a>
<span class="sourceLineNo">219</span>    predicateFeatures.addAll(predicateExtractor.extract(jCas, predicate));<a name="line.219"></a>
<span class="sourceLineNo">220</span><a name="line.220"></a>
<span class="sourceLineNo">221</span>    List&lt;SemanticArgument&gt; arguments = UIMAUtil.toList(<a name="line.221"></a>
<span class="sourceLineNo">222</span>        predicate.getArguments(),<a name="line.222"></a>
<span class="sourceLineNo">223</span>        SemanticArgument.class);<a name="line.223"></a>
<span class="sourceLineNo">224</span><a name="line.224"></a>
<span class="sourceLineNo">225</span>    /*<a name="line.225"></a>
<span class="sourceLineNo">226</span>     * Iterate over arguments<a name="line.226"></a>
<span class="sourceLineNo">227</span>     */<a name="line.227"></a>
<span class="sourceLineNo">228</span>    for (SemanticArgument arg : arguments) {<a name="line.228"></a>
<span class="sourceLineNo">229</span>      if (!(arg.getAnnotation() instanceof TreebankNode)) {<a name="line.229"></a>
<span class="sourceLineNo">230</span>        logger.warning(String.format(<a name="line.230"></a>
<span class="sourceLineNo">231</span>            "skipping argument of \"%s\", because it doesn't align with the parse tree",<a name="line.231"></a>
<span class="sourceLineNo">232</span>            predicate.getCoveredText()));<a name="line.232"></a>
<span class="sourceLineNo">233</span>        continue;<a name="line.233"></a>
<span class="sourceLineNo">234</span>      }<a name="line.234"></a>
<span class="sourceLineNo">235</span><a name="line.235"></a>
<span class="sourceLineNo">236</span>      nArguments += 1;<a name="line.236"></a>
<span class="sourceLineNo">237</span><a name="line.237"></a>
<span class="sourceLineNo">238</span>      TreebankNode constituent = (TreebankNode) arg.getAnnotation();<a name="line.238"></a>
<span class="sourceLineNo">239</span><a name="line.239"></a>
<span class="sourceLineNo">240</span>      Instance&lt;String&gt; instance = new Instance&lt;String&gt;();<a name="line.240"></a>
<span class="sourceLineNo">241</span><a name="line.241"></a>
<span class="sourceLineNo">242</span>      /*<a name="line.242"></a>
<span class="sourceLineNo">243</span>       * Compute predicate-constituent features<a name="line.243"></a>
<span class="sourceLineNo">244</span>       */<a name="line.244"></a>
<span class="sourceLineNo">245</span>      instance.addAll(predicateAndConstituentExtractor.extract(jCas, predicate, constituent));<a name="line.245"></a>
<span class="sourceLineNo">246</span><a name="line.246"></a>
<span class="sourceLineNo">247</span>      /*<a name="line.247"></a>
<span class="sourceLineNo">248</span>       * Add constituent features<a name="line.248"></a>
<span class="sourceLineNo">249</span>       */<a name="line.249"></a>
<span class="sourceLineNo">250</span>      instance.addAll(sentenceConstituentFeatures.get(constituent));<a name="line.250"></a>
<span class="sourceLineNo">251</span><a name="line.251"></a>
<span class="sourceLineNo">252</span>      /*<a name="line.252"></a>
<span class="sourceLineNo">253</span>       * Add predicate features<a name="line.253"></a>
<span class="sourceLineNo">254</span>       */<a name="line.254"></a>
<span class="sourceLineNo">255</span>      instance.addAll(predicateFeatures);<a name="line.255"></a>
<span class="sourceLineNo">256</span><a name="line.256"></a>
<span class="sourceLineNo">257</span>      if (isTraining()) {<a name="line.257"></a>
<span class="sourceLineNo">258</span>        instance.setOutcome(arg.getLabel());<a name="line.258"></a>
<span class="sourceLineNo">259</span>        this.dataWriter.write(instance);<a name="line.259"></a>
<span class="sourceLineNo">260</span>      } else {<a name="line.260"></a>
<span class="sourceLineNo">261</span>        arg.setLabel(this.classifier.classify(instance.getFeatures()));<a name="line.261"></a>
<span class="sourceLineNo">262</span>      }<a name="line.262"></a>
<span class="sourceLineNo">263</span><a name="line.263"></a>
<span class="sourceLineNo">264</span>    }<a name="line.264"></a>
<span class="sourceLineNo">265</span>  }<a name="line.265"></a>
<span class="sourceLineNo">266</span><a name="line.266"></a>
<span class="sourceLineNo">267</span>  /**<a name="line.267"></a>
<span class="sourceLineNo">268</span>   * Recursively build a list of constituents under a TreebankNode.<a name="line.268"></a>
<span class="sourceLineNo">269</span>   * <a name="line.269"></a>
<span class="sourceLineNo">270</span>   * @param top<a name="line.270"></a>
<span class="sourceLineNo">271</span>   *          the root of the parse tree to operate on; &lt;b&gt;top&lt;/b&gt; itself will also be added, unless<a name="line.271"></a>
<span class="sourceLineNo">272</span>   *          it is of type TopTrebankNode<a name="line.272"></a>
<span class="sourceLineNo">273</span>   * @param constituents<a name="line.273"></a>
<span class="sourceLineNo">274</span>   *          list of nodes to add to<a name="line.274"></a>
<span class="sourceLineNo">275</span>   */<a name="line.275"></a>
<span class="sourceLineNo">276</span>  protected void collectConstituents(TreebankNode top, List&lt;TreebankNode&gt; constituents) {<a name="line.276"></a>
<span class="sourceLineNo">277</span>    if (!(top instanceof TopTreebankNode))<a name="line.277"></a>
<span class="sourceLineNo">278</span>      constituents.add(top);<a name="line.278"></a>
<span class="sourceLineNo">279</span><a name="line.279"></a>
<span class="sourceLineNo">280</span>    if (top.getChildren() == null)<a name="line.280"></a>
<span class="sourceLineNo">281</span>      return;<a name="line.281"></a>
<span class="sourceLineNo">282</span><a name="line.282"></a>
<span class="sourceLineNo">283</span>    int numberOfChildren = top.getChildren().size();<a name="line.283"></a>
<span class="sourceLineNo">284</span>    for (int i = 0; i &lt; numberOfChildren; i++) {<a name="line.284"></a>
<span class="sourceLineNo">285</span>      collectConstituents(top.getChildren(i), constituents);<a name="line.285"></a>
<span class="sourceLineNo">286</span>    }<a name="line.286"></a>
<span class="sourceLineNo">287</span>  }<a name="line.287"></a>
<span class="sourceLineNo">288</span><a name="line.288"></a>
<span class="sourceLineNo">289</span>  // ///////<a name="line.289"></a>
<span class="sourceLineNo">290</span><a name="line.290"></a>
<span class="sourceLineNo">291</span>  // public void process(JCas jCas, InstanceConsumer&lt;String&gt; consumer) throws CleartkException{<a name="line.291"></a>
<span class="sourceLineNo">292</span>  // List&lt;Sentence&gt; sentences = AnnotationRetrieval.getAnnotations(jCas, Sentence.class);<a name="line.292"></a>
<span class="sourceLineNo">293</span>  //<a name="line.293"></a>
<span class="sourceLineNo">294</span>  // for( Sentence sentence : sentences ) {<a name="line.294"></a>
<span class="sourceLineNo">295</span>  //<a name="line.295"></a>
<span class="sourceLineNo">296</span>  // logger.fine(String.format("process sentence \"%s\"", sentence.getCoveredText()));<a name="line.296"></a>
<span class="sourceLineNo">297</span>  //<a name="line.297"></a>
<span class="sourceLineNo">298</span>  // List&lt;TreebankNode&gt; sentenceConstituents = new ArrayList&lt;TreebankNode&gt;(80);<a name="line.298"></a>
<span class="sourceLineNo">299</span>  // Iterator&lt;?&gt; constituentIterator =<a name="line.299"></a>
<span class="sourceLineNo">300</span>  // jCas.getJFSIndexRepository().getAnnotationIndex(TreebankNode.type).subiterator(sentence);<a name="line.300"></a>
<span class="sourceLineNo">301</span>  // while( constituentIterator.hasNext() )<a name="line.301"></a>
<span class="sourceLineNo">302</span>  // sentenceConstituents.add((TreebankNode) constituentIterator.next());<a name="line.302"></a>
<span class="sourceLineNo">303</span>  //<a name="line.303"></a>
<span class="sourceLineNo">304</span>  // Map&lt;Integer,List&lt;Feature&gt;&gt; constituentFeatures = new HashMap&lt;Integer,List&lt;Feature&gt;&gt;(140);<a name="line.304"></a>
<span class="sourceLineNo">305</span>  // for( TreebankNode constituent : sentenceConstituents )<a name="line.305"></a>
<span class="sourceLineNo">306</span>  // constituentFeatures.put(buildKey(constituent), extractConstituentFeatures(jCas, constituent));<a name="line.306"></a>
<span class="sourceLineNo">307</span>  //<a name="line.307"></a>
<span class="sourceLineNo">308</span>  //<a name="line.308"></a>
<span class="sourceLineNo">309</span>  // Iterator&lt;?&gt; predicateIterator =<a name="line.309"></a>
<span class="sourceLineNo">310</span>  // jCas.getJFSIndexRepository().getAnnotationIndex(Predicate.type).subiterator(sentence);<a name="line.310"></a>
<span class="sourceLineNo">311</span>  // while( predicateIterator.hasNext() ) {<a name="line.311"></a>
<span class="sourceLineNo">312</span>  // Predicate predicate = (Predicate) predicateIterator.next();<a name="line.312"></a>
<span class="sourceLineNo">313</span>  //<a name="line.313"></a>
<span class="sourceLineNo">314</span>  // TreebankNode predicateNode = AnnotationRetrieval.getMatchingAnnotation(jCas,<a name="line.314"></a>
<span class="sourceLineNo">315</span>  // predicate.getAnnotation(), TreebankNode.class);<a name="line.315"></a>
<span class="sourceLineNo">316</span>  // Token predicateToken = AnnotationRetrieval.getMatchingAnnotation(jCas,<a name="line.316"></a>
<span class="sourceLineNo">317</span>  // predicate.getAnnotation(), Token.class);<a name="line.317"></a>
<span class="sourceLineNo">318</span>  //<a name="line.318"></a>
<span class="sourceLineNo">319</span>  // List&lt;Feature&gt; predicateFeatures = extractPredicateFeatures(jCas, predicate, predicateNode,<a name="line.319"></a>
<span class="sourceLineNo">320</span>  // predicateToken);<a name="line.320"></a>
<span class="sourceLineNo">321</span>  //<a name="line.321"></a>
<span class="sourceLineNo">322</span>  // List&lt;Argument&gt; predicateArguments = UIMAUtil.toList(predicate.getArguments(), Argument.class);<a name="line.322"></a>
<span class="sourceLineNo">323</span>  //<a name="line.323"></a>
<span class="sourceLineNo">324</span>  // ListIterator&lt;Argument&gt; iterator = predicateArguments.listIterator();<a name="line.324"></a>
<span class="sourceLineNo">325</span>  // while( iterator.hasNext() ) {<a name="line.325"></a>
<span class="sourceLineNo">326</span>  // SemanticArgument sarg;<a name="line.326"></a>
<span class="sourceLineNo">327</span>  // try {<a name="line.327"></a>
<span class="sourceLineNo">328</span>  // sarg = (SemanticArgument) iterator.next();<a name="line.328"></a>
<span class="sourceLineNo">329</span>  // } catch( ClassCastException e) {<a name="line.329"></a>
<span class="sourceLineNo">330</span>  // continue;<a name="line.330"></a>
<span class="sourceLineNo">331</span>  // }<a name="line.331"></a>
<span class="sourceLineNo">332</span>  //<a name="line.332"></a>
<span class="sourceLineNo">333</span>  // if (sarg.getAnnotation() == null) {<a name="line.333"></a>
<span class="sourceLineNo">334</span>  // String message = "annotation property of SemanticArgument must be set";<a name="line.334"></a>
<span class="sourceLineNo">335</span>  // throw new IllegalArgumentException(message);<a name="line.335"></a>
<span class="sourceLineNo">336</span>  // }<a name="line.336"></a>
<span class="sourceLineNo">337</span>  // TreebankNode constituent = AnnotationRetrieval.getMatchingAnnotation(jCas,<a name="line.337"></a>
<span class="sourceLineNo">338</span>  // sarg.getAnnotation(), TreebankNode.class);<a name="line.338"></a>
<span class="sourceLineNo">339</span>  //<a name="line.339"></a>
<span class="sourceLineNo">340</span>  // Instance&lt;String&gt; instance = new Instance&lt;String&gt;();<a name="line.340"></a>
<span class="sourceLineNo">341</span>  // instance.addAll(predicateFeatures);<a name="line.341"></a>
<span class="sourceLineNo">342</span>  // instance.addAll(constituentFeatures.get(buildKey(constituent)));<a name="line.342"></a>
<span class="sourceLineNo">343</span>  //<a name="line.343"></a>
<span class="sourceLineNo">344</span>  // instance.addAll(relPosExtractor.extract(jCas, constituent, predicate.getAnnotation()));<a name="line.344"></a>
<span class="sourceLineNo">345</span>  // instance.addAll(pathExtractor.extract(jCas, constituent, predicateNode));<a name="line.345"></a>
<span class="sourceLineNo">346</span>  //<a name="line.346"></a>
<span class="sourceLineNo">347</span>  // if (sarg.getFeature() != null ) {<a name="line.347"></a>
<span class="sourceLineNo">348</span>  // instance.setOutcome(sarg.getLabel() + "-" + sarg.getFeature());<a name="line.348"></a>
<span class="sourceLineNo">349</span>  // } else {<a name="line.349"></a>
<span class="sourceLineNo">350</span>  // instance.setOutcome(sarg.getLabel());<a name="line.350"></a>
<span class="sourceLineNo">351</span>  // }<a name="line.351"></a>
<span class="sourceLineNo">352</span>  //<a name="line.352"></a>
<span class="sourceLineNo">353</span>  // String outcome = consumer.consume(instance);<a name="line.353"></a>
<span class="sourceLineNo">354</span>  //<a name="line.354"></a>
<span class="sourceLineNo">355</span>  // if( outcome != null ) {<a name="line.355"></a>
<span class="sourceLineNo">356</span>  // if( outcome.equals("NULL") ) {<a name="line.356"></a>
<span class="sourceLineNo">357</span>  // iterator.remove();<a name="line.357"></a>
<span class="sourceLineNo">358</span>  // } else {<a name="line.358"></a>
<span class="sourceLineNo">359</span>  // String[] parts = outcome.split("-", 1);<a name="line.359"></a>
<span class="sourceLineNo">360</span>  // sarg.setLabel(parts[0]);<a name="line.360"></a>
<span class="sourceLineNo">361</span>  // if( parts.length &gt; 1 )<a name="line.361"></a>
<span class="sourceLineNo">362</span>  // sarg.setFeature(parts[1]);<a name="line.362"></a>
<span class="sourceLineNo">363</span>  //<a name="line.363"></a>
<span class="sourceLineNo">364</span>  // sarg.removeFromIndexes();<a name="line.364"></a>
<span class="sourceLineNo">365</span>  // sarg.addToIndexes();<a name="line.365"></a>
<span class="sourceLineNo">366</span>  // }<a name="line.366"></a>
<span class="sourceLineNo">367</span>  // }<a name="line.367"></a>
<span class="sourceLineNo">368</span>  //<a name="line.368"></a>
<span class="sourceLineNo">369</span>  // }<a name="line.369"></a>
<span class="sourceLineNo">370</span>  //<a name="line.370"></a>
<span class="sourceLineNo">371</span>  // predicate.setArguments(UIMAUtil.toFSArray(jCas, predicateArguments));<a name="line.371"></a>
<span class="sourceLineNo">372</span>  // }<a name="line.372"></a>
<span class="sourceLineNo">373</span>  // }<a name="line.373"></a>
<span class="sourceLineNo">374</span>  //<a name="line.374"></a>
<span class="sourceLineNo">375</span>  // }<a name="line.375"></a>
<span class="sourceLineNo">376</span>  //<a name="line.376"></a>
<span class="sourceLineNo">377</span>  // private Integer buildKey(TreebankNode constituent) {<a name="line.377"></a>
<span class="sourceLineNo">378</span>  // return constituent.getAddress();<a name="line.378"></a>
<span class="sourceLineNo">379</span>  // }<a name="line.379"></a>
<span class="sourceLineNo">380</span>  //<a name="line.380"></a>
<span class="sourceLineNo">381</span>  // private List&lt;Feature&gt; extractConstituentFeatures(JCas jCas, TreebankNode constituent) {<a name="line.381"></a>
<span class="sourceLineNo">382</span>  // List&lt;Feature&gt; features = new ArrayList&lt;Feature&gt;(30);<a name="line.382"></a>
<span class="sourceLineNo">383</span>  // features.addAll(this.constituentExtractor.extract(jCas, constituent));<a name="line.383"></a>
<span class="sourceLineNo">384</span>  //<a name="line.384"></a>
<span class="sourceLineNo">385</span>  // TreebankNode parent = constituent.getParent();<a name="line.385"></a>
<span class="sourceLineNo">386</span>  // if( parent != null ) {<a name="line.386"></a>
<span class="sourceLineNo">387</span>  // features.addAll(this.parentExtractor.extract(jCas, parent));<a name="line.387"></a>
<span class="sourceLineNo">388</span>  // List&lt;TreebankNode&gt; children = UIMAUtil.toList(parent.getChildren(), TreebankNode.class);<a name="line.388"></a>
<span class="sourceLineNo">389</span>  // int index = children.indexOf(constituent);<a name="line.389"></a>
<span class="sourceLineNo">390</span>  // if( index &gt; 0 )<a name="line.390"></a>
<span class="sourceLineNo">391</span>  // features.addAll(this.leftSiblingExtractor.extract(jCas, children.get(index-1)));<a name="line.391"></a>
<span class="sourceLineNo">392</span>  // if( index &lt; children.size() - 1 )<a name="line.392"></a>
<span class="sourceLineNo">393</span>  // features.addAll(this.rightSiblingExtractor.extract(jCas, children.get(index+1)));<a name="line.393"></a>
<span class="sourceLineNo">394</span>  // }<a name="line.394"></a>
<span class="sourceLineNo">395</span>  //<a name="line.395"></a>
<span class="sourceLineNo">396</span>  // return features;<a name="line.396"></a>
<span class="sourceLineNo">397</span>  // }<a name="line.397"></a>
<span class="sourceLineNo">398</span>  //<a name="line.398"></a>
<span class="sourceLineNo">399</span>  // List&lt;Feature&gt; extractPredicateFeatures(JCas jCas, Predicate predicate, TreebankNode<a name="line.399"></a>
<span class="sourceLineNo">400</span>  // predicateNode, Token predicateToken) {<a name="line.400"></a>
<span class="sourceLineNo">401</span>  // List&lt;Feature&gt; features = new ArrayList&lt;Feature&gt;(8);<a name="line.401"></a>
<span class="sourceLineNo">402</span>  // features.addAll(predicateTokenExtractor.extract(jCas, predicateToken));<a name="line.402"></a>
<span class="sourceLineNo">403</span>  // features.addAll(predicateNodeExtractor.extract(jCas, predicateNode));<a name="line.403"></a>
<span class="sourceLineNo">404</span>  // return features;<a name="line.404"></a>
<span class="sourceLineNo">405</span>  // }<a name="line.405"></a>
<span class="sourceLineNo">406</span><a name="line.406"></a>
<span class="sourceLineNo">407</span>  private SimpleFeatureExtractor predicateExtractor;<a name="line.407"></a>
<span class="sourceLineNo">408</span><a name="line.408"></a>
<span class="sourceLineNo">409</span>  private SimpleFeatureExtractor constituentExtractor;<a name="line.409"></a>
<span class="sourceLineNo">410</span><a name="line.410"></a>
<span class="sourceLineNo">411</span>  private AnnotationPairFeatureExtractor predicateAndConstituentExtractor;<a name="line.411"></a>
<span class="sourceLineNo">412</span><a name="line.412"></a>
<span class="sourceLineNo">413</span>  private int nSentences;<a name="line.413"></a>
<span class="sourceLineNo">414</span><a name="line.414"></a>
<span class="sourceLineNo">415</span>  private int nPredicates;<a name="line.415"></a>
<span class="sourceLineNo">416</span><a name="line.416"></a>
<span class="sourceLineNo">417</span>  private int nArguments;<a name="line.417"></a>
<span class="sourceLineNo">418</span><a name="line.418"></a>
<span class="sourceLineNo">419</span>  private Logger logger = Logger.getLogger(this.getClass().getName());<a name="line.419"></a>
<span class="sourceLineNo">420</span><a name="line.420"></a>
<span class="sourceLineNo">421</span>}<a name="line.421"></a>




























































</pre>
</div>
</body>
</html>
