<HTML>
<BODY BGCOLOR="white">
<PRE>
<FONT color="green">001</FONT>    /* <a name="line.1"></a>
<FONT color="green">002</FONT>     * Copyright (c) 2012, Regents of the University of Colorado <a name="line.2"></a>
<FONT color="green">003</FONT>     * All rights reserved.<a name="line.3"></a>
<FONT color="green">004</FONT>     * <a name="line.4"></a>
<FONT color="green">005</FONT>     * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<FONT color="green">006</FONT>     * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<FONT color="green">007</FONT>     * <a name="line.7"></a>
<FONT color="green">008</FONT>     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<FONT color="green">009</FONT>     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<FONT color="green">010</FONT>     * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<FONT color="green">011</FONT>     * <a name="line.11"></a>
<FONT color="green">012</FONT>     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<FONT color="green">013</FONT>     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<FONT color="green">014</FONT>     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<FONT color="green">015</FONT>     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<FONT color="green">016</FONT>     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<FONT color="green">017</FONT>     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<FONT color="green">018</FONT>     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<FONT color="green">019</FONT>     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<FONT color="green">020</FONT>     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<FONT color="green">021</FONT>     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<FONT color="green">022</FONT>     * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<FONT color="green">023</FONT>     */<a name="line.23"></a>
<FONT color="green">024</FONT>    package org.cleartk.classifier.chunking;<a name="line.24"></a>
<FONT color="green">025</FONT>    <a name="line.25"></a>
<FONT color="green">026</FONT>    import java.lang.reflect.Constructor;<a name="line.26"></a>
<FONT color="green">027</FONT>    import java.lang.reflect.InvocationTargetException;<a name="line.27"></a>
<FONT color="green">028</FONT>    import java.util.ArrayList;<a name="line.28"></a>
<FONT color="green">029</FONT>    import java.util.List;<a name="line.29"></a>
<FONT color="green">030</FONT>    import java.util.Map;<a name="line.30"></a>
<FONT color="green">031</FONT>    <a name="line.31"></a>
<FONT color="green">032</FONT>    import org.apache.uima.analysis_engine.AnalysisEngineProcessException;<a name="line.32"></a>
<FONT color="green">033</FONT>    import org.apache.uima.cas.Feature;<a name="line.33"></a>
<FONT color="green">034</FONT>    import org.apache.uima.jcas.JCas;<a name="line.34"></a>
<FONT color="green">035</FONT>    import org.apache.uima.jcas.tcas.Annotation;<a name="line.35"></a>
<FONT color="green">036</FONT>    <a name="line.36"></a>
<FONT color="green">037</FONT>    /**<a name="line.37"></a>
<FONT color="green">038</FONT>     * Base class for classes that assemble individual classifier outcomes on smaller annotations<a name="line.38"></a>
<FONT color="green">039</FONT>     * ("sub-chunks") to form larger annotations ("chunks").<a name="line.39"></a>
<FONT color="green">040</FONT>     * <a name="line.40"></a>
<FONT color="green">041</FONT>     * &lt;br&gt;<a name="line.41"></a>
<FONT color="green">042</FONT>     * Copyright (c) 2012, Regents of the University of Colorado &lt;br&gt;<a name="line.42"></a>
<FONT color="green">043</FONT>     * All rights reserved.<a name="line.43"></a>
<FONT color="green">044</FONT>     * <a name="line.44"></a>
<FONT color="green">045</FONT>     * @author Steven Bethard<a name="line.45"></a>
<FONT color="green">046</FONT>     */<a name="line.46"></a>
<FONT color="green">047</FONT>    public abstract class Chunking_ImplBase&lt;SUB_CHUNK_TYPE extends Annotation, CHUNK_TYPE extends Annotation&gt;<a name="line.47"></a>
<FONT color="green">048</FONT>        implements Chunking&lt;String, SUB_CHUNK_TYPE, CHUNK_TYPE&gt; {<a name="line.48"></a>
<FONT color="green">049</FONT>    <a name="line.49"></a>
<FONT color="green">050</FONT>      protected Class&lt;? extends CHUNK_TYPE&gt; chunkClass;<a name="line.50"></a>
<FONT color="green">051</FONT>    <a name="line.51"></a>
<FONT color="green">052</FONT>      protected Class&lt;? extends SUB_CHUNK_TYPE&gt; subChunkClass;<a name="line.52"></a>
<FONT color="green">053</FONT>    <a name="line.53"></a>
<FONT color="green">054</FONT>      protected String featureFullName;<a name="line.54"></a>
<FONT color="green">055</FONT>    <a name="line.55"></a>
<FONT color="green">056</FONT>      public Chunking_ImplBase(<a name="line.56"></a>
<FONT color="green">057</FONT>          Class&lt;? extends SUB_CHUNK_TYPE&gt; subChunkClass,<a name="line.57"></a>
<FONT color="green">058</FONT>          Class&lt;? extends CHUNK_TYPE&gt; chunkClass,<a name="line.58"></a>
<FONT color="green">059</FONT>          String featureName) {<a name="line.59"></a>
<FONT color="green">060</FONT>        this.subChunkClass = subChunkClass;<a name="line.60"></a>
<FONT color="green">061</FONT>        this.chunkClass = chunkClass;<a name="line.61"></a>
<FONT color="green">062</FONT>        this.featureFullName = featureName == null ? null : chunkClass.getCanonicalName() + ":"<a name="line.62"></a>
<FONT color="green">063</FONT>            + featureName;<a name="line.63"></a>
<FONT color="green">064</FONT>      }<a name="line.64"></a>
<FONT color="green">065</FONT>    <a name="line.65"></a>
<FONT color="green">066</FONT>      protected Feature getFeature(JCas jCas) {<a name="line.66"></a>
<FONT color="green">067</FONT>        String name = this.featureFullName;<a name="line.67"></a>
<FONT color="green">068</FONT>        return name == null ? null : jCas.getTypeSystem().getFeatureByFullName(name);<a name="line.68"></a>
<FONT color="green">069</FONT>      }<a name="line.69"></a>
<FONT color="green">070</FONT>    <a name="line.70"></a>
<FONT color="green">071</FONT>      protected String getOutcomeSuffix(CHUNK_TYPE chunk, Feature feature) {<a name="line.71"></a>
<FONT color="green">072</FONT>        return feature == null ? "" : "-" + chunk.getFeatureValueAsString(feature);<a name="line.72"></a>
<FONT color="green">073</FONT>      }<a name="line.73"></a>
<FONT color="green">074</FONT>    <a name="line.74"></a>
<FONT color="green">075</FONT>      /**<a name="line.75"></a>
<FONT color="green">076</FONT>       * Produce a map from sub-chunk annotations to their outcome prefixes (e.g. 'I', 'O').<a name="line.76"></a>
<FONT color="green">077</FONT>       * <a name="line.77"></a>
<FONT color="green">078</FONT>       * If any sub-chunk annotations are not included in the map, they will be given prefix 'O'.<a name="line.78"></a>
<FONT color="green">079</FONT>       * <a name="line.79"></a>
<FONT color="green">080</FONT>       * @param subChunks<a name="line.80"></a>
<FONT color="green">081</FONT>       *          The sub-annotations that make up the chunks.<a name="line.81"></a>
<FONT color="green">082</FONT>       * @param chunks<a name="line.82"></a>
<FONT color="green">083</FONT>       *          The chunk annotations.<a name="line.83"></a>
<FONT color="green">084</FONT>       * @return A mapping from chunk sub-chunk annotations to outcome prefixes.<a name="line.84"></a>
<FONT color="green">085</FONT>       */<a name="line.85"></a>
<FONT color="green">086</FONT>      protected abstract Map&lt;SUB_CHUNK_TYPE, String&gt; getSubChunkToOutcomeMap(<a name="line.86"></a>
<FONT color="green">087</FONT>          JCas jCas,<a name="line.87"></a>
<FONT color="green">088</FONT>          List&lt;SUB_CHUNK_TYPE&gt; subChunks,<a name="line.88"></a>
<FONT color="green">089</FONT>          List&lt;CHUNK_TYPE&gt; chunks);<a name="line.89"></a>
<FONT color="green">090</FONT>    <a name="line.90"></a>
<FONT color="green">091</FONT>      @Override<a name="line.91"></a>
<FONT color="green">092</FONT>      public List&lt;String&gt; createOutcomes(JCas jCas, List&lt;SUB_CHUNK_TYPE&gt; subChunks, List&lt;CHUNK_TYPE&gt; chunks)<a name="line.92"></a>
<FONT color="green">093</FONT>          throws AnalysisEngineProcessException {<a name="line.93"></a>
<FONT color="green">094</FONT>    <a name="line.94"></a>
<FONT color="green">095</FONT>        // get the mapping from sub-chunks to their outcomes<a name="line.95"></a>
<FONT color="green">096</FONT>        Map&lt;SUB_CHUNK_TYPE, String&gt; subChunkToOutcome;<a name="line.96"></a>
<FONT color="green">097</FONT>        subChunkToOutcome = this.getSubChunkToOutcomeMap(jCas, subChunks, chunks);<a name="line.97"></a>
<FONT color="green">098</FONT>    <a name="line.98"></a>
<FONT color="green">099</FONT>        // create one outcome for each sub-chunk by combining the prefix and feature value<a name="line.99"></a>
<FONT color="green">100</FONT>        List&lt;String&gt; outcomes = new ArrayList&lt;String&gt;();<a name="line.100"></a>
<FONT color="green">101</FONT>        for (SUB_CHUNK_TYPE subChunk : subChunks) {<a name="line.101"></a>
<FONT color="green">102</FONT>          String outcome = subChunkToOutcome.get(subChunk);<a name="line.102"></a>
<FONT color="green">103</FONT>          if (outcome == null) {<a name="line.103"></a>
<FONT color="green">104</FONT>            outcome = "O";<a name="line.104"></a>
<FONT color="green">105</FONT>          }<a name="line.105"></a>
<FONT color="green">106</FONT>          outcomes.add(outcome);<a name="line.106"></a>
<FONT color="green">107</FONT>        }<a name="line.107"></a>
<FONT color="green">108</FONT>        return outcomes;<a name="line.108"></a>
<FONT color="green">109</FONT>      }<a name="line.109"></a>
<FONT color="green">110</FONT>    <a name="line.110"></a>
<FONT color="green">111</FONT>      /**<a name="line.111"></a>
<FONT color="green">112</FONT>       * Determines whether the current outcome represents the end of a chunk.<a name="line.112"></a>
<FONT color="green">113</FONT>       * <a name="line.113"></a>
<FONT color="green">114</FONT>       * Both the current outcome and the following outcome are provided for making this decision.<a name="line.114"></a>
<FONT color="green">115</FONT>       * <a name="line.115"></a>
<FONT color="green">116</FONT>       * @param currPrefix<a name="line.116"></a>
<FONT color="green">117</FONT>       *          The prefix of the current outcome<a name="line.117"></a>
<FONT color="green">118</FONT>       * @param currLabel<a name="line.118"></a>
<FONT color="green">119</FONT>       *          The label of the current outcome<a name="line.119"></a>
<FONT color="green">120</FONT>       * @param nextPrefix<a name="line.120"></a>
<FONT color="green">121</FONT>       *          The prefix of the following outcome<a name="line.121"></a>
<FONT color="green">122</FONT>       * @param nextLabel<a name="line.122"></a>
<FONT color="green">123</FONT>       *          The label of the following outcome<a name="line.123"></a>
<FONT color="green">124</FONT>       * @return True if the current outcome represents the end of a chunk<a name="line.124"></a>
<FONT color="green">125</FONT>       */<a name="line.125"></a>
<FONT color="green">126</FONT>      protected abstract boolean isEndOfChunk(<a name="line.126"></a>
<FONT color="green">127</FONT>          char currPrefix,<a name="line.127"></a>
<FONT color="green">128</FONT>          String currLabel,<a name="line.128"></a>
<FONT color="green">129</FONT>          char nextPrefix,<a name="line.129"></a>
<FONT color="green">130</FONT>          String nextLabel);<a name="line.130"></a>
<FONT color="green">131</FONT>    <a name="line.131"></a>
<FONT color="green">132</FONT>      @Override<a name="line.132"></a>
<FONT color="green">133</FONT>      public List&lt;CHUNK_TYPE&gt; createChunks(JCas jCas, List&lt;SUB_CHUNK_TYPE&gt; subChunks, List&lt;String&gt; outcomes)<a name="line.133"></a>
<FONT color="green">134</FONT>          throws AnalysisEngineProcessException {<a name="line.134"></a>
<FONT color="green">135</FONT>    <a name="line.135"></a>
<FONT color="green">136</FONT>        // validate parameters<a name="line.136"></a>
<FONT color="green">137</FONT>        int nSubChunks = subChunks.size();<a name="line.137"></a>
<FONT color="green">138</FONT>        int nOutcomes = outcomes.size();<a name="line.138"></a>
<FONT color="green">139</FONT>        if (nSubChunks != nOutcomes) {<a name="line.139"></a>
<FONT color="green">140</FONT>          String message = "expected the same number of sub-chunks (%d) as outcome s(%d)";<a name="line.140"></a>
<FONT color="green">141</FONT>          throw new IllegalArgumentException(String.format(message, nSubChunks, nOutcomes));<a name="line.141"></a>
<FONT color="green">142</FONT>        }<a name="line.142"></a>
<FONT color="green">143</FONT>    <a name="line.143"></a>
<FONT color="green">144</FONT>        // get the Feature object if we need to assign an attribute<a name="line.144"></a>
<FONT color="green">145</FONT>        Feature feature;<a name="line.145"></a>
<FONT color="green">146</FONT>        if (this.featureFullName == null) {<a name="line.146"></a>
<FONT color="green">147</FONT>          feature = null;<a name="line.147"></a>
<FONT color="green">148</FONT>        } else {<a name="line.148"></a>
<FONT color="green">149</FONT>          feature = jCas.getTypeSystem().getFeatureByFullName(this.featureFullName);<a name="line.149"></a>
<FONT color="green">150</FONT>        }<a name="line.150"></a>
<FONT color="green">151</FONT>    <a name="line.151"></a>
<FONT color="green">152</FONT>        // parse outcomes, and add a final Outside outcome for ease of parsing<a name="line.152"></a>
<FONT color="green">153</FONT>        List&lt;ChunkOutcome&gt; chunkOutcomes = new ArrayList&lt;ChunkOutcome&gt;();<a name="line.153"></a>
<FONT color="green">154</FONT>        for (String outcome : outcomes) {<a name="line.154"></a>
<FONT color="green">155</FONT>          chunkOutcomes.add(new ChunkOutcome(outcome));<a name="line.155"></a>
<FONT color="green">156</FONT>        }<a name="line.156"></a>
<FONT color="green">157</FONT>        chunkOutcomes.add(new ChunkOutcome("O"));<a name="line.157"></a>
<FONT color="green">158</FONT>    <a name="line.158"></a>
<FONT color="green">159</FONT>        // create chunk annotations as appropriate for the outcomes<a name="line.159"></a>
<FONT color="green">160</FONT>        List&lt;CHUNK_TYPE&gt; chunks = new ArrayList&lt;CHUNK_TYPE&gt;();<a name="line.160"></a>
<FONT color="green">161</FONT>        for (int i = 0; i &lt; outcomes.size(); ++i) {<a name="line.161"></a>
<FONT color="green">162</FONT>          ChunkOutcome outcome = chunkOutcomes.get(i);<a name="line.162"></a>
<FONT color="green">163</FONT>    <a name="line.163"></a>
<FONT color="green">164</FONT>          // if we're at the beginning of a chunk, gather outcomes until we hit the end of the chunk<a name="line.164"></a>
<FONT color="green">165</FONT>          // (a chunk ends when we hit 'O' or when the label change, e.g. I-PER I-ORG)<a name="line.165"></a>
<FONT color="green">166</FONT>          if (outcome.prefix != 'O') {<a name="line.166"></a>
<FONT color="green">167</FONT>    <a name="line.167"></a>
<FONT color="green">168</FONT>            // advance to the end of this chunk<a name="line.168"></a>
<FONT color="green">169</FONT>            int begin = i;<a name="line.169"></a>
<FONT color="green">170</FONT>            int end = i;<a name="line.170"></a>
<FONT color="green">171</FONT>            while (true) {<a name="line.171"></a>
<FONT color="green">172</FONT>              ChunkOutcome curr = chunkOutcomes.get(end);<a name="line.172"></a>
<FONT color="green">173</FONT>              ChunkOutcome next = chunkOutcomes.get(end + 1);<a name="line.173"></a>
<FONT color="green">174</FONT>              if (this.isEndOfChunk(curr.prefix, curr.label, next.prefix, next.label)) {<a name="line.174"></a>
<FONT color="green">175</FONT>                break;<a name="line.175"></a>
<FONT color="green">176</FONT>              }<a name="line.176"></a>
<FONT color="green">177</FONT>              ++end;<a name="line.177"></a>
<FONT color="green">178</FONT>            }<a name="line.178"></a>
<FONT color="green">179</FONT>    <a name="line.179"></a>
<FONT color="green">180</FONT>            // skip over all the outcomes we just consumed<a name="line.180"></a>
<FONT color="green">181</FONT>            i = end;<a name="line.181"></a>
<FONT color="green">182</FONT>    <a name="line.182"></a>
<FONT color="green">183</FONT>            // convert the outcome indexes into CAS offsets<a name="line.183"></a>
<FONT color="green">184</FONT>            begin = subChunks.get(begin).getBegin();<a name="line.184"></a>
<FONT color="green">185</FONT>            end = subChunks.get(end).getEnd();<a name="line.185"></a>
<FONT color="green">186</FONT>    <a name="line.186"></a>
<FONT color="green">187</FONT>            // construct the chunk annotation<a name="line.187"></a>
<FONT color="green">188</FONT>            Constructor&lt;? extends CHUNK_TYPE&gt; constructor;<a name="line.188"></a>
<FONT color="green">189</FONT>            try {<a name="line.189"></a>
<FONT color="green">190</FONT>              constructor = this.chunkClass.getConstructor(JCas.class, int.class, int.class);<a name="line.190"></a>
<FONT color="green">191</FONT>            } catch (NoSuchMethodException e) {<a name="line.191"></a>
<FONT color="green">192</FONT>              throw new AnalysisEngineProcessException(e);<a name="line.192"></a>
<FONT color="green">193</FONT>            }<a name="line.193"></a>
<FONT color="green">194</FONT>            CHUNK_TYPE chunk;<a name="line.194"></a>
<FONT color="green">195</FONT>            try {<a name="line.195"></a>
<FONT color="green">196</FONT>              chunk = constructor.newInstance(jCas, begin, end);<a name="line.196"></a>
<FONT color="green">197</FONT>            } catch (InstantiationException e) {<a name="line.197"></a>
<FONT color="green">198</FONT>              throw new AnalysisEngineProcessException(e);<a name="line.198"></a>
<FONT color="green">199</FONT>            } catch (IllegalAccessException e) {<a name="line.199"></a>
<FONT color="green">200</FONT>              throw new AnalysisEngineProcessException(e);<a name="line.200"></a>
<FONT color="green">201</FONT>            } catch (InvocationTargetException e) {<a name="line.201"></a>
<FONT color="green">202</FONT>              throw new AnalysisEngineProcessException(e);<a name="line.202"></a>
<FONT color="green">203</FONT>            }<a name="line.203"></a>
<FONT color="green">204</FONT>    <a name="line.204"></a>
<FONT color="green">205</FONT>            // set the annotation feature if necessary<a name="line.205"></a>
<FONT color="green">206</FONT>            if (this.featureFullName != null) {<a name="line.206"></a>
<FONT color="green">207</FONT>              chunk.setFeatureValueFromString(feature, outcome.label);<a name="line.207"></a>
<FONT color="green">208</FONT>            }<a name="line.208"></a>
<FONT color="green">209</FONT>    <a name="line.209"></a>
<FONT color="green">210</FONT>            // add the chunk to the CAS and to the result list<a name="line.210"></a>
<FONT color="green">211</FONT>            chunk.addToIndexes();<a name="line.211"></a>
<FONT color="green">212</FONT>            chunks.add(chunk);<a name="line.212"></a>
<FONT color="green">213</FONT>          }<a name="line.213"></a>
<FONT color="green">214</FONT>        }<a name="line.214"></a>
<FONT color="green">215</FONT>        return chunks;<a name="line.215"></a>
<FONT color="green">216</FONT>      }<a name="line.216"></a>
<FONT color="green">217</FONT>    <a name="line.217"></a>
<FONT color="green">218</FONT>      private static class ChunkOutcome {<a name="line.218"></a>
<FONT color="green">219</FONT>        public char prefix;<a name="line.219"></a>
<FONT color="green">220</FONT>    <a name="line.220"></a>
<FONT color="green">221</FONT>        public String label;<a name="line.221"></a>
<FONT color="green">222</FONT>    <a name="line.222"></a>
<FONT color="green">223</FONT>        public ChunkOutcome(String outcome) {<a name="line.223"></a>
<FONT color="green">224</FONT>          this.prefix = outcome.charAt(0);<a name="line.224"></a>
<FONT color="green">225</FONT>          this.label = outcome.length() &lt; 2 ? "" : outcome.substring(2);<a name="line.225"></a>
<FONT color="green">226</FONT>          if ("BIO".indexOf(this.prefix) == -1) {<a name="line.226"></a>
<FONT color="green">227</FONT>            throw new IllegalArgumentException("Unrecognized BIO outcome: " + outcome);<a name="line.227"></a>
<FONT color="green">228</FONT>          }<a name="line.228"></a>
<FONT color="green">229</FONT>        }<a name="line.229"></a>
<FONT color="green">230</FONT>      }<a name="line.230"></a>
<FONT color="green">231</FONT>    }<a name="line.231"></a>




























































</PRE>
</BODY>
</HTML>
