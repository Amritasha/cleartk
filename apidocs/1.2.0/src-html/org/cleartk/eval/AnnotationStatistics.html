<HTML>
<BODY BGCOLOR="white">
<PRE>
<FONT color="green">001</FONT>    /* <a name="line.1"></a>
<FONT color="green">002</FONT>     * Copyright (c) 2012, Regents of the University of Colorado <a name="line.2"></a>
<FONT color="green">003</FONT>     * All rights reserved.<a name="line.3"></a>
<FONT color="green">004</FONT>     * <a name="line.4"></a>
<FONT color="green">005</FONT>     * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<FONT color="green">006</FONT>     * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<FONT color="green">007</FONT>     * <a name="line.7"></a>
<FONT color="green">008</FONT>     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<FONT color="green">009</FONT>     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<FONT color="green">010</FONT>     * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<FONT color="green">011</FONT>     * <a name="line.11"></a>
<FONT color="green">012</FONT>     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<FONT color="green">013</FONT>     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<FONT color="green">014</FONT>     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<FONT color="green">015</FONT>     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<FONT color="green">016</FONT>     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<FONT color="green">017</FONT>     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<FONT color="green">018</FONT>     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<FONT color="green">019</FONT>     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<FONT color="green">020</FONT>     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<FONT color="green">021</FONT>     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<FONT color="green">022</FONT>     * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<FONT color="green">023</FONT>     */<a name="line.23"></a>
<FONT color="green">024</FONT>    package org.cleartk.eval;<a name="line.24"></a>
<FONT color="green">025</FONT>    <a name="line.25"></a>
<FONT color="green">026</FONT>    import java.io.Serializable;<a name="line.26"></a>
<FONT color="green">027</FONT>    import java.util.ArrayList;<a name="line.27"></a>
<FONT color="green">028</FONT>    import java.util.Collection;<a name="line.28"></a>
<FONT color="green">029</FONT>    import java.util.Collections;<a name="line.29"></a>
<FONT color="green">030</FONT>    import java.util.HashMap;<a name="line.30"></a>
<FONT color="green">031</FONT>    import java.util.HashSet;<a name="line.31"></a>
<FONT color="green">032</FONT>    import java.util.List;<a name="line.32"></a>
<FONT color="green">033</FONT>    import java.util.Map;<a name="line.33"></a>
<FONT color="green">034</FONT>    import java.util.Set;<a name="line.34"></a>
<FONT color="green">035</FONT>    <a name="line.35"></a>
<FONT color="green">036</FONT>    import org.apache.uima.cas.Feature;<a name="line.36"></a>
<FONT color="green">037</FONT>    import org.apache.uima.jcas.cas.TOP;<a name="line.37"></a>
<FONT color="green">038</FONT>    import org.apache.uima.jcas.tcas.Annotation;<a name="line.38"></a>
<FONT color="green">039</FONT>    import org.cleartk.eval.util.ConfusionMatrix;<a name="line.39"></a>
<FONT color="green">040</FONT>    <a name="line.40"></a>
<FONT color="green">041</FONT>    import com.google.common.base.Function;<a name="line.41"></a>
<FONT color="green">042</FONT>    import com.google.common.base.Objects;<a name="line.42"></a>
<FONT color="green">043</FONT>    import com.google.common.base.Objects.ToStringHelper;<a name="line.43"></a>
<FONT color="green">044</FONT>    import com.google.common.collect.HashMultiset;<a name="line.44"></a>
<FONT color="green">045</FONT>    import com.google.common.collect.Multiset;<a name="line.45"></a>
<FONT color="green">046</FONT>    <a name="line.46"></a>
<FONT color="green">047</FONT>    /**<a name="line.47"></a>
<FONT color="green">048</FONT>     * Stores statistics for comparing {@link Annotation}s extracted by a system to gold<a name="line.48"></a>
<FONT color="green">049</FONT>     * {@link Annotation}s.<a name="line.49"></a>
<FONT color="green">050</FONT>     * <a name="line.50"></a>
<FONT color="green">051</FONT>     * &lt;br&gt;<a name="line.51"></a>
<FONT color="green">052</FONT>     * Copyright (c) 2012, Regents of the University of Colorado &lt;br&gt;<a name="line.52"></a>
<FONT color="green">053</FONT>     * All rights reserved.<a name="line.53"></a>
<FONT color="green">054</FONT>     * <a name="line.54"></a>
<FONT color="green">055</FONT>     * @author Steven Bethard<a name="line.55"></a>
<FONT color="green">056</FONT>     */<a name="line.56"></a>
<FONT color="green">057</FONT>    public class AnnotationStatistics&lt;OUTCOME_TYPE extends Comparable&lt;? super OUTCOME_TYPE&gt;&gt; implements<a name="line.57"></a>
<FONT color="green">058</FONT>        Serializable {<a name="line.58"></a>
<FONT color="green">059</FONT>    <a name="line.59"></a>
<FONT color="green">060</FONT>      private static final long serialVersionUID = 1L;<a name="line.60"></a>
<FONT color="green">061</FONT>    <a name="line.61"></a>
<FONT color="green">062</FONT>      private Multiset&lt;OUTCOME_TYPE&gt; referenceOutcomes;<a name="line.62"></a>
<FONT color="green">063</FONT>    <a name="line.63"></a>
<FONT color="green">064</FONT>      private Multiset&lt;OUTCOME_TYPE&gt; predictedOutcomes;<a name="line.64"></a>
<FONT color="green">065</FONT>    <a name="line.65"></a>
<FONT color="green">066</FONT>      private Multiset&lt;OUTCOME_TYPE&gt; correctOutcomes;<a name="line.66"></a>
<FONT color="green">067</FONT>    <a name="line.67"></a>
<FONT color="green">068</FONT>      private ConfusionMatrix&lt;OUTCOME_TYPE&gt; confusionMatrix;<a name="line.68"></a>
<FONT color="green">069</FONT>    <a name="line.69"></a>
<FONT color="green">070</FONT>      /**<a name="line.70"></a>
<FONT color="green">071</FONT>       * Creates a {@link Function} that converts an {@link Annotation} into a hashable representation<a name="line.71"></a>
<FONT color="green">072</FONT>       * of its begin and end offsets.<a name="line.72"></a>
<FONT color="green">073</FONT>       * <a name="line.73"></a>
<FONT color="green">074</FONT>       * The {@link Function} created by this method is suitable for passing to the first<a name="line.74"></a>
<FONT color="green">075</FONT>       * {@link Function} argument of {@link #add(Collection, Collection, Function, Function)}.<a name="line.75"></a>
<FONT color="green">076</FONT>       */<a name="line.76"></a>
<FONT color="green">077</FONT>      public static &lt;ANNOTATION_TYPE extends Annotation&gt; Function&lt;ANNOTATION_TYPE, Span&gt; annotationToSpan() {<a name="line.77"></a>
<FONT color="green">078</FONT>        return new Function&lt;ANNOTATION_TYPE, Span&gt;() {<a name="line.78"></a>
<FONT color="green">079</FONT>          @Override<a name="line.79"></a>
<FONT color="green">080</FONT>          public Span apply(ANNOTATION_TYPE annotation) {<a name="line.80"></a>
<FONT color="green">081</FONT>            return new Span(annotation);<a name="line.81"></a>
<FONT color="green">082</FONT>          }<a name="line.82"></a>
<FONT color="green">083</FONT>        };<a name="line.83"></a>
<FONT color="green">084</FONT>      }<a name="line.84"></a>
<FONT color="green">085</FONT>    <a name="line.85"></a>
<FONT color="green">086</FONT>      /**<a name="line.86"></a>
<FONT color="green">087</FONT>       * Creates a {@link Function} that extracts a feature value from a {@link TOP}.<a name="line.87"></a>
<FONT color="green">088</FONT>       * <a name="line.88"></a>
<FONT color="green">089</FONT>       * The {@link Function} created by this method is suitable for passing to the second<a name="line.89"></a>
<FONT color="green">090</FONT>       * {@link Function} argument of {@link #add(Collection, Collection, Function, Function)}.<a name="line.90"></a>
<FONT color="green">091</FONT>       * <a name="line.91"></a>
<FONT color="green">092</FONT>       * @param featureName<a name="line.92"></a>
<FONT color="green">093</FONT>       *          The name of the feature whose value is to be extracted.<a name="line.93"></a>
<FONT color="green">094</FONT>       */<a name="line.94"></a>
<FONT color="green">095</FONT>      public static &lt;ANNOTATION_TYPE extends TOP&gt; Function&lt;ANNOTATION_TYPE, String&gt; annotationToFeatureValue(<a name="line.95"></a>
<FONT color="green">096</FONT>          final String featureName) {<a name="line.96"></a>
<FONT color="green">097</FONT>        return new Function&lt;ANNOTATION_TYPE, String&gt;() {<a name="line.97"></a>
<FONT color="green">098</FONT>          @Override<a name="line.98"></a>
<FONT color="green">099</FONT>          public String apply(ANNOTATION_TYPE annotation) {<a name="line.99"></a>
<FONT color="green">100</FONT>            Feature feature = annotation.getType().getFeatureByBaseName(featureName);<a name="line.100"></a>
<FONT color="green">101</FONT>            return annotation.getFeatureValueAsString(feature);<a name="line.101"></a>
<FONT color="green">102</FONT>          }<a name="line.102"></a>
<FONT color="green">103</FONT>        };<a name="line.103"></a>
<FONT color="green">104</FONT>      }<a name="line.104"></a>
<FONT color="green">105</FONT>    <a name="line.105"></a>
<FONT color="green">106</FONT>      /**<a name="line.106"></a>
<FONT color="green">107</FONT>       * Creates a {@link Function} that always returns null.<a name="line.107"></a>
<FONT color="green">108</FONT>       * <a name="line.108"></a>
<FONT color="green">109</FONT>       * This may be useful when only the span of the offset is important, but you still need to pass in<a name="line.109"></a>
<FONT color="green">110</FONT>       * the final argument of {@link #add(Collection, Collection, Function, Function)}.<a name="line.110"></a>
<FONT color="green">111</FONT>       */<a name="line.111"></a>
<FONT color="green">112</FONT>      public static &lt;ANNOTATION_TYPE, OUTCOME_TYPE&gt; Function&lt;ANNOTATION_TYPE, OUTCOME_TYPE&gt; annotationToNull() {<a name="line.112"></a>
<FONT color="green">113</FONT>        return new Function&lt;ANNOTATION_TYPE, OUTCOME_TYPE&gt;() {<a name="line.113"></a>
<FONT color="green">114</FONT>          @Override<a name="line.114"></a>
<FONT color="green">115</FONT>          public OUTCOME_TYPE apply(ANNOTATION_TYPE annotation) {<a name="line.115"></a>
<FONT color="green">116</FONT>            return null;<a name="line.116"></a>
<FONT color="green">117</FONT>          }<a name="line.117"></a>
<FONT color="green">118</FONT>        };<a name="line.118"></a>
<FONT color="green">119</FONT>      }<a name="line.119"></a>
<FONT color="green">120</FONT>    <a name="line.120"></a>
<FONT color="green">121</FONT>      /**<a name="line.121"></a>
<FONT color="green">122</FONT>       * Add all statistics together.<a name="line.122"></a>
<FONT color="green">123</FONT>       * <a name="line.123"></a>
<FONT color="green">124</FONT>       * This is often useful for combining individual fold statistics that result from methods like<a name="line.124"></a>
<FONT color="green">125</FONT>       * {@link Evaluation_ImplBase#crossValidation(List, int)}.<a name="line.125"></a>
<FONT color="green">126</FONT>       * <a name="line.126"></a>
<FONT color="green">127</FONT>       * @param statistics<a name="line.127"></a>
<FONT color="green">128</FONT>       *          The sequence of statistics that should be combined.<a name="line.128"></a>
<FONT color="green">129</FONT>       * @return The combination of all the individual statistics.<a name="line.129"></a>
<FONT color="green">130</FONT>       */<a name="line.130"></a>
<FONT color="green">131</FONT>      public static &lt;OUTCOME_TYPE extends Comparable&lt;? super OUTCOME_TYPE&gt;&gt; AnnotationStatistics&lt;OUTCOME_TYPE&gt; addAll(<a name="line.131"></a>
<FONT color="green">132</FONT>          Iterable&lt;AnnotationStatistics&lt;OUTCOME_TYPE&gt;&gt; statistics) {<a name="line.132"></a>
<FONT color="green">133</FONT>        AnnotationStatistics&lt;OUTCOME_TYPE&gt; result = new AnnotationStatistics&lt;OUTCOME_TYPE&gt;();<a name="line.133"></a>
<FONT color="green">134</FONT>        for (AnnotationStatistics&lt;OUTCOME_TYPE&gt; item : statistics) {<a name="line.134"></a>
<FONT color="green">135</FONT>          result.addAll(item);<a name="line.135"></a>
<FONT color="green">136</FONT>        }<a name="line.136"></a>
<FONT color="green">137</FONT>        return result;<a name="line.137"></a>
<FONT color="green">138</FONT>      }<a name="line.138"></a>
<FONT color="green">139</FONT>    <a name="line.139"></a>
<FONT color="green">140</FONT>      /**<a name="line.140"></a>
<FONT color="green">141</FONT>       * Create an AnnotationStatistics that compares {@link Annotation}s based on their begin and end<a name="line.141"></a>
<FONT color="green">142</FONT>       * offsets, plus a {@link Feature} of the {@link Annotation} that represents the outcome or label.<a name="line.142"></a>
<FONT color="green">143</FONT>       */<a name="line.143"></a>
<FONT color="green">144</FONT>      public AnnotationStatistics() {<a name="line.144"></a>
<FONT color="green">145</FONT>        this.referenceOutcomes = HashMultiset.create();<a name="line.145"></a>
<FONT color="green">146</FONT>        this.predictedOutcomes = HashMultiset.create();<a name="line.146"></a>
<FONT color="green">147</FONT>        this.correctOutcomes = HashMultiset.create();<a name="line.147"></a>
<FONT color="green">148</FONT>        this.confusionMatrix = new ConfusionMatrix&lt;OUTCOME_TYPE&gt;();<a name="line.148"></a>
<FONT color="green">149</FONT>      }<a name="line.149"></a>
<FONT color="green">150</FONT>    <a name="line.150"></a>
<FONT color="green">151</FONT>      /**<a name="line.151"></a>
<FONT color="green">152</FONT>       * Update the statistics, comparing the reference annotations to the predicted annotations.<a name="line.152"></a>
<FONT color="green">153</FONT>       * <a name="line.153"></a>
<FONT color="green">154</FONT>       * Annotations are considered to match if they have the same character offsets in the text. All<a name="line.154"></a>
<FONT color="green">155</FONT>       * outcomes (e.g. as returned in {@link #confusions()}) will be &lt;code&gt;null&lt;/code&gt;.<a name="line.155"></a>
<FONT color="green">156</FONT>       * <a name="line.156"></a>
<FONT color="green">157</FONT>       * @param referenceAnnotations<a name="line.157"></a>
<FONT color="green">158</FONT>       *          The reference annotations, typically identified by humans.<a name="line.158"></a>
<FONT color="green">159</FONT>       * @param predictedAnnotations<a name="line.159"></a>
<FONT color="green">160</FONT>       *          The predicted annotations, typically identified by a model.<a name="line.160"></a>
<FONT color="green">161</FONT>       */<a name="line.161"></a>
<FONT color="green">162</FONT>      public &lt;ANNOTATION_TYPE extends Annotation&gt; void add(<a name="line.162"></a>
<FONT color="green">163</FONT>          Collection&lt;? extends ANNOTATION_TYPE&gt; referenceAnnotations,<a name="line.163"></a>
<FONT color="green">164</FONT>          Collection&lt;? extends ANNOTATION_TYPE&gt; predictedAnnotations) {<a name="line.164"></a>
<FONT color="green">165</FONT>        this.add(<a name="line.165"></a>
<FONT color="green">166</FONT>            referenceAnnotations,<a name="line.166"></a>
<FONT color="green">167</FONT>            predictedAnnotations,<a name="line.167"></a>
<FONT color="green">168</FONT>            AnnotationStatistics.&lt;ANNOTATION_TYPE&gt; annotationToSpan(),<a name="line.168"></a>
<FONT color="green">169</FONT>            AnnotationStatistics.&lt;ANNOTATION_TYPE, OUTCOME_TYPE&gt; annotationToNull());<a name="line.169"></a>
<FONT color="green">170</FONT>      }<a name="line.170"></a>
<FONT color="green">171</FONT>    <a name="line.171"></a>
<FONT color="green">172</FONT>      /**<a name="line.172"></a>
<FONT color="green">173</FONT>       * Update the statistics, comparing the reference annotations to the predicted annotations.<a name="line.173"></a>
<FONT color="green">174</FONT>       * <a name="line.174"></a>
<FONT color="green">175</FONT>       * Annotations are considered to match if they have the same span (according to<a name="line.175"></a>
<FONT color="green">176</FONT>       * {@code annotationToSpan}) and if they have the same outcome (according to<a name="line.176"></a>
<FONT color="green">177</FONT>       * {@code annotationToOutcome}).<a name="line.177"></a>
<FONT color="green">178</FONT>       * <a name="line.178"></a>
<FONT color="green">179</FONT>       * @param referenceAnnotations<a name="line.179"></a>
<FONT color="green">180</FONT>       *          The reference annotations, typically identified by humans.<a name="line.180"></a>
<FONT color="green">181</FONT>       * @param predictedAnnotations<a name="line.181"></a>
<FONT color="green">182</FONT>       *          The predicted annotations, typically identified by a model.<a name="line.182"></a>
<FONT color="green">183</FONT>       * @param annotationToSpan<a name="line.183"></a>
<FONT color="green">184</FONT>       *          A function that defines how to convert an annotation into a hashable object that<a name="line.184"></a>
<FONT color="green">185</FONT>       *          represents the span of that annotation. The {@link #annotationToSpan()} method<a name="line.185"></a>
<FONT color="green">186</FONT>       *          provides an example function that could be used here.<a name="line.186"></a>
<FONT color="green">187</FONT>       * @param annotationToOutcome<a name="line.187"></a>
<FONT color="green">188</FONT>       *          A function that defines how to convert an annotation into an object that represents<a name="line.188"></a>
<FONT color="green">189</FONT>       *          the outcome (or "label") assigned to that annotation. The<a name="line.189"></a>
<FONT color="green">190</FONT>       *          {@link #annotationToFeatureValue(String)} method provides a sample function that could<a name="line.190"></a>
<FONT color="green">191</FONT>       *          be used here.<a name="line.191"></a>
<FONT color="green">192</FONT>       */<a name="line.192"></a>
<FONT color="green">193</FONT>      public &lt;ANNOTATION_TYPE, SPAN_TYPE&gt; void add(<a name="line.193"></a>
<FONT color="green">194</FONT>          Collection&lt;? extends ANNOTATION_TYPE&gt; referenceAnnotations,<a name="line.194"></a>
<FONT color="green">195</FONT>          Collection&lt;? extends ANNOTATION_TYPE&gt; predictedAnnotations,<a name="line.195"></a>
<FONT color="green">196</FONT>          Function&lt;ANNOTATION_TYPE, SPAN_TYPE&gt; annotationToSpan,<a name="line.196"></a>
<FONT color="green">197</FONT>          Function&lt;ANNOTATION_TYPE, OUTCOME_TYPE&gt; annotationToOutcome) {<a name="line.197"></a>
<FONT color="green">198</FONT>    <a name="line.198"></a>
<FONT color="green">199</FONT>        // map gold spans to their outcomes<a name="line.199"></a>
<FONT color="green">200</FONT>        Map&lt;SPAN_TYPE, OUTCOME_TYPE&gt; referenceSpanOutcomes = new HashMap&lt;SPAN_TYPE, OUTCOME_TYPE&gt;();<a name="line.200"></a>
<FONT color="green">201</FONT>        for (ANNOTATION_TYPE ann : referenceAnnotations) {<a name="line.201"></a>
<FONT color="green">202</FONT>          referenceSpanOutcomes.put(annotationToSpan.apply(ann), annotationToOutcome.apply(ann));<a name="line.202"></a>
<FONT color="green">203</FONT>        }<a name="line.203"></a>
<FONT color="green">204</FONT>    <a name="line.204"></a>
<FONT color="green">205</FONT>        // map system spans to their outcomes<a name="line.205"></a>
<FONT color="green">206</FONT>        Map&lt;SPAN_TYPE, OUTCOME_TYPE&gt; predictedSpanOutcomes = new HashMap&lt;SPAN_TYPE, OUTCOME_TYPE&gt;();<a name="line.206"></a>
<FONT color="green">207</FONT>        for (ANNOTATION_TYPE ann : predictedAnnotations) {<a name="line.207"></a>
<FONT color="green">208</FONT>          predictedSpanOutcomes.put(annotationToSpan.apply(ann), annotationToOutcome.apply(ann));<a name="line.208"></a>
<FONT color="green">209</FONT>        }<a name="line.209"></a>
<FONT color="green">210</FONT>    <a name="line.210"></a>
<FONT color="green">211</FONT>        // update the gold and system outcomes<a name="line.211"></a>
<FONT color="green">212</FONT>        this.referenceOutcomes.addAll(referenceSpanOutcomes.values());<a name="line.212"></a>
<FONT color="green">213</FONT>        this.predictedOutcomes.addAll(predictedSpanOutcomes.values());<a name="line.213"></a>
<FONT color="green">214</FONT>    <a name="line.214"></a>
<FONT color="green">215</FONT>        // determine the outcomes that were correct<a name="line.215"></a>
<FONT color="green">216</FONT>        Set&lt;SPAN_TYPE&gt; intersection = new HashSet&lt;SPAN_TYPE&gt;();<a name="line.216"></a>
<FONT color="green">217</FONT>        intersection.addAll(referenceSpanOutcomes.keySet());<a name="line.217"></a>
<FONT color="green">218</FONT>        intersection.retainAll(predictedSpanOutcomes.keySet());<a name="line.218"></a>
<FONT color="green">219</FONT>        for (SPAN_TYPE span : intersection) {<a name="line.219"></a>
<FONT color="green">220</FONT>          OUTCOME_TYPE goldOutcome = referenceSpanOutcomes.get(span);<a name="line.220"></a>
<FONT color="green">221</FONT>          OUTCOME_TYPE systemOutcome = predictedSpanOutcomes.get(span);<a name="line.221"></a>
<FONT color="green">222</FONT>          if (Objects.equal(goldOutcome, systemOutcome)) {<a name="line.222"></a>
<FONT color="green">223</FONT>            this.correctOutcomes.add(goldOutcome);<a name="line.223"></a>
<FONT color="green">224</FONT>          }<a name="line.224"></a>
<FONT color="green">225</FONT>        }<a name="line.225"></a>
<FONT color="green">226</FONT>    <a name="line.226"></a>
<FONT color="green">227</FONT>        // update the confusion matrix<a name="line.227"></a>
<FONT color="green">228</FONT>        Set&lt;SPAN_TYPE&gt; union = new HashSet&lt;SPAN_TYPE&gt;();<a name="line.228"></a>
<FONT color="green">229</FONT>        union.addAll(referenceSpanOutcomes.keySet());<a name="line.229"></a>
<FONT color="green">230</FONT>        union.addAll(predictedSpanOutcomes.keySet());<a name="line.230"></a>
<FONT color="green">231</FONT>        for (SPAN_TYPE span : union) {<a name="line.231"></a>
<FONT color="green">232</FONT>          OUTCOME_TYPE goldOutcome = referenceSpanOutcomes.get(span);<a name="line.232"></a>
<FONT color="green">233</FONT>          OUTCOME_TYPE systemOutcome = predictedSpanOutcomes.get(span);<a name="line.233"></a>
<FONT color="green">234</FONT>          this.confusionMatrix.add(goldOutcome, systemOutcome);<a name="line.234"></a>
<FONT color="green">235</FONT>        }<a name="line.235"></a>
<FONT color="green">236</FONT>      }<a name="line.236"></a>
<FONT color="green">237</FONT>    <a name="line.237"></a>
<FONT color="green">238</FONT>      /**<a name="line.238"></a>
<FONT color="green">239</FONT>       * Adds all the statistics collected by another AnnotationStatistics to this one.<a name="line.239"></a>
<FONT color="green">240</FONT>       * <a name="line.240"></a>
<FONT color="green">241</FONT>       * @param that<a name="line.241"></a>
<FONT color="green">242</FONT>       *          The other statistics that should be added to this one.<a name="line.242"></a>
<FONT color="green">243</FONT>       */<a name="line.243"></a>
<FONT color="green">244</FONT>      public void addAll(AnnotationStatistics&lt;OUTCOME_TYPE&gt; that) {<a name="line.244"></a>
<FONT color="green">245</FONT>        this.referenceOutcomes.addAll(that.referenceOutcomes);<a name="line.245"></a>
<FONT color="green">246</FONT>        this.predictedOutcomes.addAll(that.predictedOutcomes);<a name="line.246"></a>
<FONT color="green">247</FONT>        this.correctOutcomes.addAll(that.correctOutcomes);<a name="line.247"></a>
<FONT color="green">248</FONT>        this.confusionMatrix.add(that.confusionMatrix);<a name="line.248"></a>
<FONT color="green">249</FONT>      }<a name="line.249"></a>
<FONT color="green">250</FONT>    <a name="line.250"></a>
<FONT color="green">251</FONT>      /**<a name="line.251"></a>
<FONT color="green">252</FONT>       * Returns the {@link ConfusionMatrix} tabulating reference outcomes matched to predicted<a name="line.252"></a>
<FONT color="green">253</FONT>       * outcomes.<a name="line.253"></a>
<FONT color="green">254</FONT>       * <a name="line.254"></a>
<FONT color="green">255</FONT>       * @return The confusion matrix.<a name="line.255"></a>
<FONT color="green">256</FONT>       */<a name="line.256"></a>
<FONT color="green">257</FONT>      public ConfusionMatrix&lt;OUTCOME_TYPE&gt; confusions() {<a name="line.257"></a>
<FONT color="green">258</FONT>        return this.confusionMatrix;<a name="line.258"></a>
<FONT color="green">259</FONT>      }<a name="line.259"></a>
<FONT color="green">260</FONT>    <a name="line.260"></a>
<FONT color="green">261</FONT>      public double precision() {<a name="line.261"></a>
<FONT color="green">262</FONT>        int nSystem = this.predictedOutcomes.size();<a name="line.262"></a>
<FONT color="green">263</FONT>        return nSystem == 0 ? 1.0 : ((double) this.correctOutcomes.size()) / nSystem;<a name="line.263"></a>
<FONT color="green">264</FONT>      }<a name="line.264"></a>
<FONT color="green">265</FONT>    <a name="line.265"></a>
<FONT color="green">266</FONT>      public double precision(OUTCOME_TYPE outcome) {<a name="line.266"></a>
<FONT color="green">267</FONT>        int nSystem = this.predictedOutcomes.count(outcome);<a name="line.267"></a>
<FONT color="green">268</FONT>        return nSystem == 0 ? 1.0 : ((double) this.correctOutcomes.count(outcome)) / nSystem;<a name="line.268"></a>
<FONT color="green">269</FONT>      }<a name="line.269"></a>
<FONT color="green">270</FONT>    <a name="line.270"></a>
<FONT color="green">271</FONT>      public double recall() {<a name="line.271"></a>
<FONT color="green">272</FONT>        int nGold = this.referenceOutcomes.size();<a name="line.272"></a>
<FONT color="green">273</FONT>        return nGold == 0 ? 1.0 : ((double) this.correctOutcomes.size()) / nGold;<a name="line.273"></a>
<FONT color="green">274</FONT>      }<a name="line.274"></a>
<FONT color="green">275</FONT>    <a name="line.275"></a>
<FONT color="green">276</FONT>      public double recall(OUTCOME_TYPE outcome) {<a name="line.276"></a>
<FONT color="green">277</FONT>        int nGold = this.referenceOutcomes.count(outcome);<a name="line.277"></a>
<FONT color="green">278</FONT>        return nGold == 0 ? 1.0 : ((double) this.correctOutcomes.count(outcome)) / nGold;<a name="line.278"></a>
<FONT color="green">279</FONT>      }<a name="line.279"></a>
<FONT color="green">280</FONT>    <a name="line.280"></a>
<FONT color="green">281</FONT>      public double f1() {<a name="line.281"></a>
<FONT color="green">282</FONT>        double p = this.precision();<a name="line.282"></a>
<FONT color="green">283</FONT>        double r = this.recall();<a name="line.283"></a>
<FONT color="green">284</FONT>        double sum = p + r;<a name="line.284"></a>
<FONT color="green">285</FONT>        return sum == 0.0 ? 0.0 : (2 * p * r) / sum;<a name="line.285"></a>
<FONT color="green">286</FONT>      }<a name="line.286"></a>
<FONT color="green">287</FONT>    <a name="line.287"></a>
<FONT color="green">288</FONT>      public double f1(OUTCOME_TYPE outcome) {<a name="line.288"></a>
<FONT color="green">289</FONT>        double p = this.precision(outcome);<a name="line.289"></a>
<FONT color="green">290</FONT>        double r = this.recall(outcome);<a name="line.290"></a>
<FONT color="green">291</FONT>        double sum = p + r;<a name="line.291"></a>
<FONT color="green">292</FONT>        return sum == 0.0 ? 0.0 : (2 * p * r) / sum;<a name="line.292"></a>
<FONT color="green">293</FONT>      }<a name="line.293"></a>
<FONT color="green">294</FONT>    <a name="line.294"></a>
<FONT color="green">295</FONT>      @Override<a name="line.295"></a>
<FONT color="green">296</FONT>      public String toString() {<a name="line.296"></a>
<FONT color="green">297</FONT>        StringBuilder result = new StringBuilder();<a name="line.297"></a>
<FONT color="green">298</FONT>        result.append("P\tR\tF1\t#gold\t#system\t#correct\n");<a name="line.298"></a>
<FONT color="green">299</FONT>        result.append(String.format(<a name="line.299"></a>
<FONT color="green">300</FONT>            "%.3f\t%.3f\t%.3f\t%d\t%d\t%d\tOVERALL\n",<a name="line.300"></a>
<FONT color="green">301</FONT>            this.precision(),<a name="line.301"></a>
<FONT color="green">302</FONT>            this.recall(),<a name="line.302"></a>
<FONT color="green">303</FONT>            this.f1(),<a name="line.303"></a>
<FONT color="green">304</FONT>            this.referenceOutcomes.size(),<a name="line.304"></a>
<FONT color="green">305</FONT>            this.predictedOutcomes.size(),<a name="line.305"></a>
<FONT color="green">306</FONT>            this.correctOutcomes.size()));<a name="line.306"></a>
<FONT color="green">307</FONT>        List&lt;OUTCOME_TYPE&gt; outcomes = new ArrayList&lt;OUTCOME_TYPE&gt;(this.referenceOutcomes.elementSet());<a name="line.307"></a>
<FONT color="green">308</FONT>        if (outcomes.size() &gt; 1) {<a name="line.308"></a>
<FONT color="green">309</FONT>          Collections.sort(outcomes);<a name="line.309"></a>
<FONT color="green">310</FONT>          for (OUTCOME_TYPE outcome : outcomes) {<a name="line.310"></a>
<FONT color="green">311</FONT>            result.append(String.format(<a name="line.311"></a>
<FONT color="green">312</FONT>                "%.3f\t%.3f\t%.3f\t%d\t%d\t%d\t%s\n",<a name="line.312"></a>
<FONT color="green">313</FONT>                this.precision(outcome),<a name="line.313"></a>
<FONT color="green">314</FONT>                this.recall(outcome),<a name="line.314"></a>
<FONT color="green">315</FONT>                this.f1(outcome),<a name="line.315"></a>
<FONT color="green">316</FONT>                this.referenceOutcomes.count(outcome),<a name="line.316"></a>
<FONT color="green">317</FONT>                this.predictedOutcomes.count(outcome),<a name="line.317"></a>
<FONT color="green">318</FONT>                this.correctOutcomes.count(outcome),<a name="line.318"></a>
<FONT color="green">319</FONT>                outcome));<a name="line.319"></a>
<FONT color="green">320</FONT>          }<a name="line.320"></a>
<FONT color="green">321</FONT>        }<a name="line.321"></a>
<FONT color="green">322</FONT>        return result.toString();<a name="line.322"></a>
<FONT color="green">323</FONT>      }<a name="line.323"></a>
<FONT color="green">324</FONT>    <a name="line.324"></a>
<FONT color="green">325</FONT>      private static class Span {<a name="line.325"></a>
<FONT color="green">326</FONT>    <a name="line.326"></a>
<FONT color="green">327</FONT>        public int end;<a name="line.327"></a>
<FONT color="green">328</FONT>    <a name="line.328"></a>
<FONT color="green">329</FONT>        public int begin;<a name="line.329"></a>
<FONT color="green">330</FONT>    <a name="line.330"></a>
<FONT color="green">331</FONT>        public Span(Annotation annotation) {<a name="line.331"></a>
<FONT color="green">332</FONT>          this.begin = annotation.getBegin();<a name="line.332"></a>
<FONT color="green">333</FONT>          this.end = annotation.getEnd();<a name="line.333"></a>
<FONT color="green">334</FONT>        }<a name="line.334"></a>
<FONT color="green">335</FONT>    <a name="line.335"></a>
<FONT color="green">336</FONT>        @Override<a name="line.336"></a>
<FONT color="green">337</FONT>        public int hashCode() {<a name="line.337"></a>
<FONT color="green">338</FONT>          return Objects.hashCode(this.begin, this.end);<a name="line.338"></a>
<FONT color="green">339</FONT>        }<a name="line.339"></a>
<FONT color="green">340</FONT>    <a name="line.340"></a>
<FONT color="green">341</FONT>        @Override<a name="line.341"></a>
<FONT color="green">342</FONT>        public boolean equals(Object obj) {<a name="line.342"></a>
<FONT color="green">343</FONT>          if (!this.getClass().equals(obj.getClass())) {<a name="line.343"></a>
<FONT color="green">344</FONT>            return false;<a name="line.344"></a>
<FONT color="green">345</FONT>          }<a name="line.345"></a>
<FONT color="green">346</FONT>          Span that = (Span) obj;<a name="line.346"></a>
<FONT color="green">347</FONT>          return this.begin == that.begin &amp;&amp; this.end == that.end;<a name="line.347"></a>
<FONT color="green">348</FONT>        }<a name="line.348"></a>
<FONT color="green">349</FONT>    <a name="line.349"></a>
<FONT color="green">350</FONT>        @Override<a name="line.350"></a>
<FONT color="green">351</FONT>        public String toString() {<a name="line.351"></a>
<FONT color="green">352</FONT>          ToStringHelper helper = Objects.toStringHelper(this);<a name="line.352"></a>
<FONT color="green">353</FONT>          helper.add("begin", this.begin);<a name="line.353"></a>
<FONT color="green">354</FONT>          helper.add("end", this.end);<a name="line.354"></a>
<FONT color="green">355</FONT>          return helper.toString();<a name="line.355"></a>
<FONT color="green">356</FONT>        }<a name="line.356"></a>
<FONT color="green">357</FONT>      }<a name="line.357"></a>
<FONT color="green">358</FONT>    }<a name="line.358"></a>




























































</PRE>
</BODY>
</HTML>
