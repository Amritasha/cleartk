<HTML>
<BODY BGCOLOR="white">
<PRE>
<FONT color="green">001</FONT>    /** <a name="line.1"></a>
<FONT color="green">002</FONT>     * Copyright (c) 2007-2008, Regents of the University of Colorado <a name="line.2"></a>
<FONT color="green">003</FONT>     * All rights reserved.<a name="line.3"></a>
<FONT color="green">004</FONT>     * <a name="line.4"></a>
<FONT color="green">005</FONT>     * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<FONT color="green">006</FONT>     * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<FONT color="green">007</FONT>     * <a name="line.7"></a>
<FONT color="green">008</FONT>     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<FONT color="green">009</FONT>     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<FONT color="green">010</FONT>     * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<FONT color="green">011</FONT>     * <a name="line.11"></a>
<FONT color="green">012</FONT>     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<FONT color="green">013</FONT>     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<FONT color="green">014</FONT>     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<FONT color="green">015</FONT>     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<FONT color="green">016</FONT>     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<FONT color="green">017</FONT>     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<FONT color="green">018</FONT>     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<FONT color="green">019</FONT>     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<FONT color="green">020</FONT>     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<FONT color="green">021</FONT>     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<FONT color="green">022</FONT>     * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<FONT color="green">023</FONT>     */<a name="line.23"></a>
<FONT color="green">024</FONT>    package org.cleartk.util;<a name="line.24"></a>
<FONT color="green">025</FONT>    <a name="line.25"></a>
<FONT color="green">026</FONT>    import java.lang.reflect.InvocationTargetException;<a name="line.26"></a>
<FONT color="green">027</FONT>    import java.lang.reflect.ParameterizedType;<a name="line.27"></a>
<FONT color="green">028</FONT>    import java.lang.reflect.Type;<a name="line.28"></a>
<FONT color="green">029</FONT>    import java.lang.reflect.TypeVariable;<a name="line.29"></a>
<FONT color="green">030</FONT>    import java.util.Map;<a name="line.30"></a>
<FONT color="green">031</FONT>    import java.util.TreeMap;<a name="line.31"></a>
<FONT color="green">032</FONT>    <a name="line.32"></a>
<FONT color="green">033</FONT>    import org.apache.uima.resource.ResourceInitializationException;<a name="line.33"></a>
<FONT color="green">034</FONT>    <a name="line.34"></a>
<FONT color="green">035</FONT>    /**<a name="line.35"></a>
<FONT color="green">036</FONT>     * &lt;br&gt;<a name="line.36"></a>
<FONT color="green">037</FONT>     * Copyright (c) 2007-2008, Regents of the University of Colorado &lt;br&gt;<a name="line.37"></a>
<FONT color="green">038</FONT>     * All rights reserved.<a name="line.38"></a>
<FONT color="green">039</FONT>     */<a name="line.39"></a>
<FONT color="green">040</FONT>    public class ReflectionUtil {<a name="line.40"></a>
<FONT color="green">041</FONT>    <a name="line.41"></a>
<FONT color="green">042</FONT>      /**<a name="line.42"></a>
<FONT color="green">043</FONT>       * Perform an unchecked cast based on a type parameter.<a name="line.43"></a>
<FONT color="green">044</FONT>       * <a name="line.44"></a>
<FONT color="green">045</FONT>       * @param &lt;T&gt;<a name="line.45"></a>
<FONT color="green">046</FONT>       *          The type to which the object should be cast.<a name="line.46"></a>
<FONT color="green">047</FONT>       * @param o<a name="line.47"></a>
<FONT color="green">048</FONT>       *          The object.<a name="line.48"></a>
<FONT color="green">049</FONT>       * @return The object, cast to the given type.<a name="line.49"></a>
<FONT color="green">050</FONT>       */<a name="line.50"></a>
<FONT color="green">051</FONT>      @SuppressWarnings("unchecked")<a name="line.51"></a>
<FONT color="green">052</FONT>      public static &lt;T&gt; T uncheckedCast(Object o) {<a name="line.52"></a>
<FONT color="green">053</FONT>        return (T) o;<a name="line.53"></a>
<FONT color="green">054</FONT>      }<a name="line.54"></a>
<FONT color="green">055</FONT>    <a name="line.55"></a>
<FONT color="green">056</FONT>      public static interface TypeArgumentDelegator {<a name="line.56"></a>
<FONT color="green">057</FONT>        public Map&lt;String, Type&gt; getTypeArguments(Class&lt;?&gt; genericType);<a name="line.57"></a>
<FONT color="green">058</FONT>      }<a name="line.58"></a>
<FONT color="green">059</FONT>    <a name="line.59"></a>
<FONT color="green">060</FONT>      public static &lt;T&gt; Type getTypeArgument(Class&lt;T&gt; genericType, String typeParameterName, T obj) {<a name="line.60"></a>
<FONT color="green">061</FONT>        Map&lt;String, Type&gt; typeArguments = getTypeArguments(genericType, obj);<a name="line.61"></a>
<FONT color="green">062</FONT>        return typeArguments == null ? null : typeArguments.get(typeParameterName);<a name="line.62"></a>
<FONT color="green">063</FONT>      }<a name="line.63"></a>
<FONT color="green">064</FONT>    <a name="line.64"></a>
<FONT color="green">065</FONT>      /**<a name="line.65"></a>
<FONT color="green">066</FONT>       * Try to find the instantiation of all of genericTypes type parameters in objs class.<a name="line.66"></a>
<FONT color="green">067</FONT>       * <a name="line.67"></a>
<FONT color="green">068</FONT>       * @param genericType<a name="line.68"></a>
<FONT color="green">069</FONT>       *          the generic supertype of objs class<a name="line.69"></a>
<FONT color="green">070</FONT>       * @param obj<a name="line.70"></a>
<FONT color="green">071</FONT>       *          an instantiation of a subclass of genericType. All of genericTypes type parameters<a name="line.71"></a>
<FONT color="green">072</FONT>       *          must have been instantiated in the inheritance hierarchy.<a name="line.72"></a>
<FONT color="green">073</FONT>       * @return a map of genericTypes type parameters (their name in the source code) to the type they<a name="line.73"></a>
<FONT color="green">074</FONT>       *         are instantiated as in obj<a name="line.74"></a>
<FONT color="green">075</FONT>       */<a name="line.75"></a>
<FONT color="green">076</FONT>      public static Map&lt;String, Type&gt; getTypeArguments(Class&lt;?&gt; genericType, Object obj) {<a name="line.76"></a>
<FONT color="green">077</FONT>        if (obj instanceof TypeArgumentDelegator) {<a name="line.77"></a>
<FONT color="green">078</FONT>          return ((TypeArgumentDelegator) obj).getTypeArguments(genericType);<a name="line.78"></a>
<FONT color="green">079</FONT>        }<a name="line.79"></a>
<FONT color="green">080</FONT>        Map&lt;String, Type&gt; typeMap = new TreeMap&lt;String, Type&gt;();<a name="line.80"></a>
<FONT color="green">081</FONT>        return getTypeArguments(genericType, obj.getClass(), typeMap);<a name="line.81"></a>
<FONT color="green">082</FONT>      }<a name="line.82"></a>
<FONT color="green">083</FONT>    <a name="line.83"></a>
<FONT color="green">084</FONT>      public static boolean isAssignableFrom(Type type1, Type type2) {<a name="line.84"></a>
<FONT color="green">085</FONT>        if (type1 instanceof Class&lt;?&gt; &amp;&amp; type2 instanceof Class&lt;?&gt;) {<a name="line.85"></a>
<FONT color="green">086</FONT>          return ((Class&lt;?&gt;) type1).isAssignableFrom((Class&lt;?&gt;) type2);<a name="line.86"></a>
<FONT color="green">087</FONT>        } else {<a name="line.87"></a>
<FONT color="green">088</FONT>          return type1.equals(type2);<a name="line.88"></a>
<FONT color="green">089</FONT>        }<a name="line.89"></a>
<FONT color="green">090</FONT>      }<a name="line.90"></a>
<FONT color="green">091</FONT>    <a name="line.91"></a>
<FONT color="green">092</FONT>      private static Map&lt;String, Type&gt; getTypeArguments(<a name="line.92"></a>
<FONT color="green">093</FONT>          Class&lt;?&gt; genericType,<a name="line.93"></a>
<FONT color="green">094</FONT>          Type type,<a name="line.94"></a>
<FONT color="green">095</FONT>          Map&lt;String, Type&gt; typeMap) {<a name="line.95"></a>
<FONT color="green">096</FONT>        if (type instanceof ParameterizedType) {<a name="line.96"></a>
<FONT color="green">097</FONT>          return getTypeArguments(genericType, (ParameterizedType) type, typeMap);<a name="line.97"></a>
<FONT color="green">098</FONT>        } else if (type instanceof Class&lt;?&gt;) {<a name="line.98"></a>
<FONT color="green">099</FONT>          return getTypeArguments(genericType, (Class&lt;?&gt;) type, typeMap);<a name="line.99"></a>
<FONT color="green">100</FONT>        } else {<a name="line.100"></a>
<FONT color="green">101</FONT>          throw new IllegalArgumentException("type must be a ParameterizedType or Class");<a name="line.101"></a>
<FONT color="green">102</FONT>        }<a name="line.102"></a>
<FONT color="green">103</FONT>      }<a name="line.103"></a>
<FONT color="green">104</FONT>    <a name="line.104"></a>
<FONT color="green">105</FONT>      private static Map&lt;String, Type&gt; getTypeArguments(<a name="line.105"></a>
<FONT color="green">106</FONT>          Class&lt;?&gt; genericType,<a name="line.106"></a>
<FONT color="green">107</FONT>          Class&lt;?&gt; classType,<a name="line.107"></a>
<FONT color="green">108</FONT>          Map&lt;String, Type&gt; typeMap) {<a name="line.108"></a>
<FONT color="green">109</FONT>        if (genericType.isInterface()) {<a name="line.109"></a>
<FONT color="green">110</FONT>          for (Type interfaceType : classType.getGenericInterfaces()) {<a name="line.110"></a>
<FONT color="green">111</FONT>            Map&lt;String, Type&gt; result = getTypeArguments(genericType, interfaceType, typeMap);<a name="line.111"></a>
<FONT color="green">112</FONT>            if (result != null)<a name="line.112"></a>
<FONT color="green">113</FONT>              return result;<a name="line.113"></a>
<FONT color="green">114</FONT>          }<a name="line.114"></a>
<FONT color="green">115</FONT>        }<a name="line.115"></a>
<FONT color="green">116</FONT>    <a name="line.116"></a>
<FONT color="green">117</FONT>        Type superType = classType.getGenericSuperclass();<a name="line.117"></a>
<FONT color="green">118</FONT>        if (superType != null) {<a name="line.118"></a>
<FONT color="green">119</FONT>          return getTypeArguments(genericType, superType, typeMap);<a name="line.119"></a>
<FONT color="green">120</FONT>        }<a name="line.120"></a>
<FONT color="green">121</FONT>    <a name="line.121"></a>
<FONT color="green">122</FONT>        return null;<a name="line.122"></a>
<FONT color="green">123</FONT>      }<a name="line.123"></a>
<FONT color="green">124</FONT>    <a name="line.124"></a>
<FONT color="green">125</FONT>      private static Map&lt;String, Type&gt; getTypeArguments(<a name="line.125"></a>
<FONT color="green">126</FONT>          Class&lt;?&gt; genericType,<a name="line.126"></a>
<FONT color="green">127</FONT>          ParameterizedType paramType,<a name="line.127"></a>
<FONT color="green">128</FONT>          Map&lt;String, Type&gt; typeMap) {<a name="line.128"></a>
<FONT color="green">129</FONT>        Class&lt;?&gt; rawType = (Class&lt;?&gt;) paramType.getRawType();<a name="line.129"></a>
<FONT color="green">130</FONT>        if (rawType == genericType) {<a name="line.130"></a>
<FONT color="green">131</FONT>          // found it!<a name="line.131"></a>
<FONT color="green">132</FONT>          TypeVariable&lt;?&gt; typeVars[] = rawType.getTypeParameters();<a name="line.132"></a>
<FONT color="green">133</FONT>          Type actualTypes[] = paramType.getActualTypeArguments();<a name="line.133"></a>
<FONT color="green">134</FONT>          Map&lt;String, Type&gt; result = new TreeMap&lt;String, Type&gt;();<a name="line.134"></a>
<FONT color="green">135</FONT>          for (int i = 0; i &lt; actualTypes.length; i++) {<a name="line.135"></a>
<FONT color="green">136</FONT>            while (actualTypes[i] != null &amp;&amp; actualTypes[i] instanceof TypeVariable&lt;?&gt;) {<a name="line.136"></a>
<FONT color="green">137</FONT>              String key = typevarString((TypeVariable&lt;?&gt;) actualTypes[i]);<a name="line.137"></a>
<FONT color="green">138</FONT>              if (typeMap.containsKey(key))<a name="line.138"></a>
<FONT color="green">139</FONT>                actualTypes[i] = typeMap.get(key);<a name="line.139"></a>
<FONT color="green">140</FONT>              else<a name="line.140"></a>
<FONT color="green">141</FONT>                actualTypes[i] = null;<a name="line.141"></a>
<FONT color="green">142</FONT>            }<a name="line.142"></a>
<FONT color="green">143</FONT>            result.put(typeVars[i].getName(), actualTypes[i]);<a name="line.143"></a>
<FONT color="green">144</FONT>          }<a name="line.144"></a>
<FONT color="green">145</FONT>          return result;<a name="line.145"></a>
<FONT color="green">146</FONT>        } else {<a name="line.146"></a>
<FONT color="green">147</FONT>          TypeVariable&lt;?&gt; typeVars[] = rawType.getTypeParameters();<a name="line.147"></a>
<FONT color="green">148</FONT>          Type actualTypes[] = paramType.getActualTypeArguments();<a name="line.148"></a>
<FONT color="green">149</FONT>          for (int i = 0; i &lt; typeVars.length; i++)<a name="line.149"></a>
<FONT color="green">150</FONT>            typeMap.put(typevarString(typeVars[i]), actualTypes[i]);<a name="line.150"></a>
<FONT color="green">151</FONT>          return getTypeArguments(genericType, paramType.getRawType(), typeMap);<a name="line.151"></a>
<FONT color="green">152</FONT>        }<a name="line.152"></a>
<FONT color="green">153</FONT>      }<a name="line.153"></a>
<FONT color="green">154</FONT>    <a name="line.154"></a>
<FONT color="green">155</FONT>      private static String typevarString(TypeVariable&lt;?&gt; tv) {<a name="line.155"></a>
<FONT color="green">156</FONT>        return tv.getGenericDeclaration().toString() + " " + tv.getName();<a name="line.156"></a>
<FONT color="green">157</FONT>      }<a name="line.157"></a>
<FONT color="green">158</FONT>    <a name="line.158"></a>
<FONT color="green">159</FONT>      /**<a name="line.159"></a>
<FONT color="green">160</FONT>       * Checks that the given type parameters of the given objects are compatible.<a name="line.160"></a>
<FONT color="green">161</FONT>       * <a name="line.161"></a>
<FONT color="green">162</FONT>       * Type parameters are identified by providing the class in which the type parameter is defined,<a name="line.162"></a>
<FONT color="green">163</FONT>       * and the declared name of the type parameter.<a name="line.163"></a>
<FONT color="green">164</FONT>       * <a name="line.164"></a>
<FONT color="green">165</FONT>       * Throws a ResourceInitializationException if the type parameters are not compatible.<a name="line.165"></a>
<FONT color="green">166</FONT>       * <a name="line.166"></a>
<FONT color="green">167</FONT>       * @param &lt;T&gt;<a name="line.167"></a>
<FONT color="green">168</FONT>       *          Type of the class declaring the first type parameter<a name="line.168"></a>
<FONT color="green">169</FONT>       * @param &lt;U&gt;<a name="line.169"></a>
<FONT color="green">170</FONT>       *          Type of the class declaring the second type parameter<a name="line.170"></a>
<FONT color="green">171</FONT>       * @param paramDefiningClass1<a name="line.171"></a>
<FONT color="green">172</FONT>       *          The class declaring the first type parameter<a name="line.172"></a>
<FONT color="green">173</FONT>       * @param paramName1<a name="line.173"></a>
<FONT color="green">174</FONT>       *          The declared name of the first type parameter<a name="line.174"></a>
<FONT color="green">175</FONT>       * @param object1<a name="line.175"></a>
<FONT color="green">176</FONT>       *          The target object<a name="line.176"></a>
<FONT color="green">177</FONT>       * @param paramDefiningClass2<a name="line.177"></a>
<FONT color="green">178</FONT>       *          The class declaring the second type parameter<a name="line.178"></a>
<FONT color="green">179</FONT>       * @param paramName2<a name="line.179"></a>
<FONT color="green">180</FONT>       *          The declared name of the second type parameter<a name="line.180"></a>
<FONT color="green">181</FONT>       * @param object2<a name="line.181"></a>
<FONT color="green">182</FONT>       *          The source object<a name="line.182"></a>
<FONT color="green">183</FONT>       */<a name="line.183"></a>
<FONT color="green">184</FONT>      public static &lt;T, U&gt; void checkTypeParameterIsAssignable(<a name="line.184"></a>
<FONT color="green">185</FONT>          Class&lt;T&gt; paramDefiningClass1,<a name="line.185"></a>
<FONT color="green">186</FONT>          String paramName1,<a name="line.186"></a>
<FONT color="green">187</FONT>          T object1,<a name="line.187"></a>
<FONT color="green">188</FONT>          Class&lt;U&gt; paramDefiningClass2,<a name="line.188"></a>
<FONT color="green">189</FONT>          String paramName2,<a name="line.189"></a>
<FONT color="green">190</FONT>          U object2) throws ResourceInitializationException {<a name="line.190"></a>
<FONT color="green">191</FONT>    <a name="line.191"></a>
<FONT color="green">192</FONT>        // get the type arguments from the objects<a name="line.192"></a>
<FONT color="green">193</FONT>        java.lang.reflect.Type type1 = ReflectionUtil.getTypeArgument(<a name="line.193"></a>
<FONT color="green">194</FONT>            paramDefiningClass1,<a name="line.194"></a>
<FONT color="green">195</FONT>            paramName1,<a name="line.195"></a>
<FONT color="green">196</FONT>            object1);<a name="line.196"></a>
<FONT color="green">197</FONT>        java.lang.reflect.Type type2 = ReflectionUtil.getTypeArgument(<a name="line.197"></a>
<FONT color="green">198</FONT>            paramDefiningClass2,<a name="line.198"></a>
<FONT color="green">199</FONT>            paramName2,<a name="line.199"></a>
<FONT color="green">200</FONT>            object2);<a name="line.200"></a>
<FONT color="green">201</FONT>    <a name="line.201"></a>
<FONT color="green">202</FONT>        // both arguments missing is compatible<a name="line.202"></a>
<FONT color="green">203</FONT>        if (type1 == null &amp;&amp; type2 == null) {<a name="line.203"></a>
<FONT color="green">204</FONT>          return;<a name="line.204"></a>
<FONT color="green">205</FONT>        }<a name="line.205"></a>
<FONT color="green">206</FONT>    <a name="line.206"></a>
<FONT color="green">207</FONT>        // if the second type is not assignable to the first, raise an exception<a name="line.207"></a>
<FONT color="green">208</FONT>        if (type1 == null || type2 == null || !ReflectionUtil.isAssignableFrom(type1, type2)) {<a name="line.208"></a>
<FONT color="green">209</FONT>          throw CleartkInitializationException.incompatibleTypeParameters(<a name="line.209"></a>
<FONT color="green">210</FONT>              object1,<a name="line.210"></a>
<FONT color="green">211</FONT>              paramName1,<a name="line.211"></a>
<FONT color="green">212</FONT>              type1,<a name="line.212"></a>
<FONT color="green">213</FONT>              object2,<a name="line.213"></a>
<FONT color="green">214</FONT>              paramName2,<a name="line.214"></a>
<FONT color="green">215</FONT>              type2);<a name="line.215"></a>
<FONT color="green">216</FONT>        }<a name="line.216"></a>
<FONT color="green">217</FONT>      }<a name="line.217"></a>
<FONT color="green">218</FONT>    <a name="line.218"></a>
<FONT color="green">219</FONT>      /**<a name="line.219"></a>
<FONT color="green">220</FONT>       * Checks that the given type parameters of the given objects are exactly equal.<a name="line.220"></a>
<FONT color="green">221</FONT>       * <a name="line.221"></a>
<FONT color="green">222</FONT>       * Type parameters are identified by providing the class in which the type parameter is defined,<a name="line.222"></a>
<FONT color="green">223</FONT>       * and the declared name of the type parameter.<a name="line.223"></a>
<FONT color="green">224</FONT>       * <a name="line.224"></a>
<FONT color="green">225</FONT>       * Throws an instance of the given exception class if type parameters are not exactly equal.<a name="line.225"></a>
<FONT color="green">226</FONT>       * <a name="line.226"></a>
<FONT color="green">227</FONT>       * @param &lt;T&gt;<a name="line.227"></a>
<FONT color="green">228</FONT>       *          Type of the class declaring the first type parameter<a name="line.228"></a>
<FONT color="green">229</FONT>       * @param &lt;U&gt;<a name="line.229"></a>
<FONT color="green">230</FONT>       *          Type of the class declaring the second type parameter<a name="line.230"></a>
<FONT color="green">231</FONT>       * @param paramDefiningClass1<a name="line.231"></a>
<FONT color="green">232</FONT>       *          The class declaring the first type parameter<a name="line.232"></a>
<FONT color="green">233</FONT>       * @param paramName1<a name="line.233"></a>
<FONT color="green">234</FONT>       *          The declared name of the first type parameter<a name="line.234"></a>
<FONT color="green">235</FONT>       * @param object1<a name="line.235"></a>
<FONT color="green">236</FONT>       *          The target object<a name="line.236"></a>
<FONT color="green">237</FONT>       * @param paramDefiningClass2<a name="line.237"></a>
<FONT color="green">238</FONT>       *          The class declaring the second type parameter<a name="line.238"></a>
<FONT color="green">239</FONT>       * @param paramName2<a name="line.239"></a>
<FONT color="green">240</FONT>       *          The declared name of the second type parameter<a name="line.240"></a>
<FONT color="green">241</FONT>       * @param object2<a name="line.241"></a>
<FONT color="green">242</FONT>       *          The source object<a name="line.242"></a>
<FONT color="green">243</FONT>       */<a name="line.243"></a>
<FONT color="green">244</FONT>      public static &lt;T, U, E extends Exception&gt; void checkTypeParametersAreEqual(<a name="line.244"></a>
<FONT color="green">245</FONT>          Class&lt;T&gt; paramDefiningClass1,<a name="line.245"></a>
<FONT color="green">246</FONT>          String paramName1,<a name="line.246"></a>
<FONT color="green">247</FONT>          T object1,<a name="line.247"></a>
<FONT color="green">248</FONT>          Class&lt;U&gt; paramDefiningClass2,<a name="line.248"></a>
<FONT color="green">249</FONT>          String paramName2,<a name="line.249"></a>
<FONT color="green">250</FONT>          U object2,<a name="line.250"></a>
<FONT color="green">251</FONT>          Class&lt;E&gt; exceptionClass) throws E {<a name="line.251"></a>
<FONT color="green">252</FONT>    <a name="line.252"></a>
<FONT color="green">253</FONT>        // get the type arguments from the objects<a name="line.253"></a>
<FONT color="green">254</FONT>        java.lang.reflect.Type type1 = ReflectionUtil.getTypeArgument(<a name="line.254"></a>
<FONT color="green">255</FONT>            paramDefiningClass1,<a name="line.255"></a>
<FONT color="green">256</FONT>            paramName1,<a name="line.256"></a>
<FONT color="green">257</FONT>            object1);<a name="line.257"></a>
<FONT color="green">258</FONT>        java.lang.reflect.Type type2 = ReflectionUtil.getTypeArgument(<a name="line.258"></a>
<FONT color="green">259</FONT>            paramDefiningClass2,<a name="line.259"></a>
<FONT color="green">260</FONT>            paramName2,<a name="line.260"></a>
<FONT color="green">261</FONT>            object2);<a name="line.261"></a>
<FONT color="green">262</FONT>    <a name="line.262"></a>
<FONT color="green">263</FONT>        // both arguments missing is equal<a name="line.263"></a>
<FONT color="green">264</FONT>        if (type1 == null &amp;&amp; type2 == null) {<a name="line.264"></a>
<FONT color="green">265</FONT>          return;<a name="line.265"></a>
<FONT color="green">266</FONT>        }<a name="line.266"></a>
<FONT color="green">267</FONT>    <a name="line.267"></a>
<FONT color="green">268</FONT>        // if the second type is not equal to the first, raise an exception<a name="line.268"></a>
<FONT color="green">269</FONT>        if (type1 == null || type2 == null || !type1.equals(type2)) {<a name="line.269"></a>
<FONT color="green">270</FONT>          try {<a name="line.270"></a>
<FONT color="green">271</FONT>            throw exceptionClass.getConstructor(String.class).newInstance(<a name="line.271"></a>
<FONT color="green">272</FONT>                String.format(<a name="line.272"></a>
<FONT color="green">273</FONT>                    "%s with %s %s is not equal to %s with %s %s",<a name="line.273"></a>
<FONT color="green">274</FONT>                    object1.getClass().getSimpleName(),<a name="line.274"></a>
<FONT color="green">275</FONT>                    paramName1,<a name="line.275"></a>
<FONT color="green">276</FONT>                    type1,<a name="line.276"></a>
<FONT color="green">277</FONT>                    object2.getClass().getSimpleName(),<a name="line.277"></a>
<FONT color="green">278</FONT>                    paramName2,<a name="line.278"></a>
<FONT color="green">279</FONT>                    type2));<a name="line.279"></a>
<FONT color="green">280</FONT>          } catch (InstantiationException e) {<a name="line.280"></a>
<FONT color="green">281</FONT>            throw new RuntimeException(e);<a name="line.281"></a>
<FONT color="green">282</FONT>          } catch (IllegalAccessException e) {<a name="line.282"></a>
<FONT color="green">283</FONT>            throw new RuntimeException(e);<a name="line.283"></a>
<FONT color="green">284</FONT>          } catch (InvocationTargetException e) {<a name="line.284"></a>
<FONT color="green">285</FONT>            throw new RuntimeException(e);<a name="line.285"></a>
<FONT color="green">286</FONT>          } catch (NoSuchMethodException e) {<a name="line.286"></a>
<FONT color="green">287</FONT>            throw new RuntimeException(e);<a name="line.287"></a>
<FONT color="green">288</FONT>          }<a name="line.288"></a>
<FONT color="green">289</FONT>        }<a name="line.289"></a>
<FONT color="green">290</FONT>      }<a name="line.290"></a>
<FONT color="green">291</FONT>    <a name="line.291"></a>
<FONT color="green">292</FONT>    }<a name="line.292"></a>




























































</PRE>
</BODY>
</HTML>
