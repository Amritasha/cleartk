\documentclass[final]{beamer}
\mode<presentation>
{
  \usetheme{Cleartk}
}

\usepackage{color}
\usepackage{times}
\usepackage{amsmath,amssymb}
\usepackage{sfmath} % for sans serif math fonts; wget http://dtrx.de/od/tex/sfmath.sty
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage[size=custom,height=91.44,width=60.96,scale=1.0]{beamerposter}
\usepackage{booktabs,array}
\usepackage{listings}
\usepackage{xspace}
\usepackage{fp}
\usepackage{ifthen}
\usepackage{listings}

\usepackage{graphicx}

\listfiles
\newcommand*{\signstream}{SignStream\texttrademark\xspace}
\newcommand{\code}[1]{\texttt{\small #1}}


\lstset{
  language=Java,
  basicstyle=\scriptsize\ttfamily,
  keywordstyle=\color{red!60!blue}\ttfamily\bfseries,
  commentstyle=\color{green!50!black}\ttfamily,
}




\graphicspath{{/u/figures/}}

% Display a grid to help align images
%\beamertemplategridbackground[1cm]

\title{\Huge ClearTK 2.0: Design Patterns for Machine Learning in UIMA\\[0.2ex]}

\author{Steven Bethard\inst{1}, Philip Ogren\inst{2}, Lee Becker\inst{2}}
\institute[] % (optional, but mostly needed)
{
  \inst{1}%
  University of Alabama at Birmingham, Birmingham, AL, USA
  \\
  \inst{2}%
  University of Colorado Boulder, Boulder, CO, USA
}

\date[May. 29th, 2014]{May. 29th, 2014}

\begin{document}


\begin{frame}[fragile]

\vspace{-1cm}
\begin{columns}[t]
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \begin{column}{.45\linewidth}
    \begin{block}{Overview}
      \begin{itemize}
      \item ClearTK makes statistical machine learning within the UIMA framework more manageable by providing:

        \begin{itemize}
        \item A common interface and wrappers for ML libraries such as: SVMlight, LIBSVM, LIBLINEAR, OpenNLP MaxEnt and Mallet
        \item A rich feature extraction library
        \item Infrastructure for using and evaluating ML classifiers
        \item A variety of wrappers for existing NLP libraries (Stanford, CLEAR Parser, etc\ldots)
        \end{itemize}

      \item Today we reflect on 5 years of code-base evolution to:
        \begin{itemize}
        \item recommend best practices for making NLP frameworks better suited to development of components that rely on machine learning 
        \item share design patterns for making NLP frameworks more robust and accessible to the programmer
        %\item discuss lessons learned in making NLP frameworks more accessible to the programmer
        \end{itemize}
      \end{itemize}
    \end{block}
    

    \begin{block}{Annotators should be conceptually simple}
      \begin{itemize}
      \item Let developers focus on implementing UIMA's \code{AnalysisEngine.process} method
      \item Put feature extraction directly into \code{process} method
      \item Make explicit where code is used for training vs classification
      \item Place complexity in utility objects instead of class methods

          \begin{itemize}
                  \item Example: Conversion between chunk labels and token labels
          \end{itemize}

      %\item The improved \code{ClassifierAnnotator} interface now encourages Annotator developers to:
      %    \begin{itemize}
          %\item put feature extraction code in the well understood \code{process} method.
          %\item make explicit annotator functionality in both training and classification modes.
          %\end{itemize}
      %\item BIO chunking APIs were simplified by:
          %\begin{itemize}
          %\item inheriting from the already known \code{ClassifierAnnotator}
          %\item eliminating specialized interfaces
          %\item providing simple utility objects for converting between chunk labels and token labels
          %\end{itemize}

            \item Example \code{process} method of a \code{CleartkAnnotator} for BIO-chunking
    \end{itemize}
    \begin{lstlisting}
      public class NamedEntityChunker extends CleartkSequenceAnnotator<String> {
        ...
        private BioChunking<Token, NamedEntityMention> chunking = new BioChunking<>(
            Token.class, NamedEntityMention.class, "mentionType");
        ...
        public void process(JCas jCas) throws AnalysisEngineProcessException {
          for (Sentence sentence : JCasUtil.select(jCas, Sentence.class)) {
            // extract features for each token in the sentence
            List<Token> tokens = JCasUtil.selectCovered(jCas, Token.class, sentence);
            List<List<Feature>> featureLists = new ArrayList<>();
            for (Token token : tokens) {
              List<Feature> features = new ArrayList<>();
              features.addAll(this.extractor.extract(jCas, token));
              features.addAll(this.contextExtractor.extract(jCas, token));
              featureLists.add(features);
            }
            // during training, convert NamedEntityMentions in the CAS into 
            // expected classifier outcomes
            if (this.isTraining()) {
              // extract the gold (human annotated) NamedEntityMention annotations
              List<NamedEntityMention> namedEntityMentions = JCasUtil.selectCovered(
                  jCas, NamedEntityMention.class, sentence);
              // convert the NamedEntityMention annotations into token-level BIO outcome 
              // labels
              List<String> outcomes = this.chunking.createOutcomes(jCas, tokens, 
                                                                   namedEntityMentions);
              // write the features and outcomes as training instances
              this.dataWriter.write(Instances.toInstances(outcomes, featureLists));
            }
            // during classification, convert classifier outcomes into 
            // NamedEntityMentions in the CAS
            else {
              // get the predicted BIO outcome labels from the classifier
              List<String> outcomes = this.classifier.classify(featureLists);
              // create the NamedEntityMention annotations in the CAS
              this.chunking.createChunks(jCas, tokens, outcomes);
            }
          }
        }
      }
    \end{lstlisting}
    \end{block}

    \begin{block}{Code should be type system agnostic}
    \begin{itemize}
            \item The type system defines all of the annotations and attributes that may be added to a document
            \item Dependency on type system limits component reusability
            \item ClearTK avoids this pitfall by:
                    \begin{itemize}
                            \item Designing the machine learning framework completely free of the type system
                            \item Defining interfaces for operations on common types such as tokens, sentences and parses
                            \item Implementing Annotators and wrappers built atop these type interfaces.
                    \end{itemize}
    \end{itemize}
                    
    \end{block}


  \end{column}

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Begin second column
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \begin{column}{.45\linewidth}
    


    \begin{block}{Pipelines should look like pipelines}
        \begin{itemize}
            \item Interfaces should make it easy to determine how annotators are sequenced in a pipeline
        \end{itemize}

        \begin{itemize}
            \item The original ClearTK evaluation interface obfuscated how pipelines are used.
        \end{itemize}

        \begin{lstlisting}
    public interface CleartkPipelineProvider {
      public List<AnalysisEngine> getTrainingPipeline(String name);
      public void trainingPipelineComplete(String name, List<AnalysisEngine> engines);
      public void trainingComplete();
      public void train(String name, String... trainingArguments);
      ...
    }
      \end{lstlisting}

    \begin{itemize}
      \item ClearTK 2.0's interface allows the training pipeline to live in one method
    \end{itemize}

    \begin{lstlisting}
    public abstract class Evaluation_ImplBase<ITEM_TYPE, STATS_TYPE> {
      ...
      protected abstract void train(CollectionReader collectionReader, File directory);
      ...
    }
    \end{lstlisting}





    \end{block}


    \begin{block}{Collection readers should be minimal}
      \begin{itemize}
              \item UIMA's allows only a single \code{CollectionReader} per pipeline.  
                      \begin{itemize}
                        \item Translation: importing from multiple corpora requires custom readers
                      \end{itemize}
%This limits flexibility in import of multiple annotation layers.
              \item Previously ClearTK provided several custom CollectionReaders
                      \begin{itemize}
                        \item New tasks/new data required new Collection Readers. 
                      \end{itemize}
              \item ClearTK 2.0 recommends the following practices:
                      \begin{itemize}
                      \item Use only the \code{URICollectionReader}
                      \item Implement file format parsing in one or more AnalysisEngines
                      \item Avoid writing new readers, write new AnalysisEngines instead
                      \end{itemize}
      \end{itemize}
    \end{block}



    \begin{block}{Modules should match natural subsets}
            \begin{itemize}
                    %\item ClearTK 1.0 organized modules around types of annotations and corpora.
                    %\item Old organization created unncessary dependencies between similar but unrelated components (BerkeleyParser and MaltParser for example)
                    \item Better module organization yields better dependency management
                    \item Organize around programmer needs not by similarity of operation
            \end{itemize}
            {\footnotesize
                    \centering
                    \begin{tabular*}{.90\linewidth}{ll|ll}
                    \cline{1-4}
                    \cline{1-4}
                    \multicolumn{2}{c|}{\textbf{Original Organization}}  & \multicolumn{2}{c}{\textbf{ClearTK 2.0 Organization}}\\
                    \cline{1-4}
                    \cline{1-4}
                    Machine          & cleartk-chunker          & Machine          & cleartk-ml\\
                    Learning         & cleartk-ml               & Learning         & cleartk-ml-opennlp-maxent \\
                                     & cleartk-ml-grmm          &                  & cleartk-ml-svmlight \\
                                     & cleartk-ml-libsvm        &                  & cleartk-ml-tksvmlight \\
                                     & cleartk-ml-mallet        &                  & cleartk-ml-liblinear \\ 
                                     & cleartk-ml-opennlp-maxent &                 & cleartk-ml-libsvm \\
                                     & cleartk-ml-svmlight       &                 & cleartk-ml-libsvm-tk\\
                                     &                           &                 & cleartk-ml-mallet \\
                                     &                           &                 & cleartk-ml-crfsuite \\
                                     &                           &                 & cleartk-ml-weka \\
                    \cline{1-4}
                    Evaluation       & cleartk-eval              & Evaluation      & cleartk-eval \\
                    \cline{1-4}
                    Linguistic       & cleartk-named-entity  & Type System & cleartk-type-system \\
                    Phenomena            & cleartk-semantic-roles & Dependent  & cleartk-corpus \\
                                         & cleartk-stanford-corenlp &                    & cleartk-feature\\
                                        \cline{3-4}
                                         & cleartk-syntax           & Wrappers & cleartk-snowball \\
                                         & cleartk-syntax-berkeley  &                    & cleartk-opennlp-tools \\
                                         & cleartk-syntax-dependency &                   & cleartk-berkeleyparser\\
                                         & cleartk-syntax-dependency-clear &             & cleartk-clearnlp\\
                                         & cleartk-syntax-dependency-malt &              & cleartk-maltparser\\
                                         & cleartk-syntax-opennlp &                      & cleartk-stanford-corenlp\\
                                        \cline{3-4}
                                         & cleartk-timeml         & Home-grown & cleartk-token \\
                                         & cleartk-token          & Components            & cleartk-summarization\\
                                         &                        &                       & cleartk-timeml \\
                                         &                        &                       & cleartk-examples \\
                    \cline{1-4}
            \end{tabular*}
            }


    \end{block}

%    \begin{block}{Users need help past the UIMA overhead}
%
%            \begin{itemize}
%                    \item Most new users to ClearTK simply want to extract features and train a classifier
%                    \item Conversely UIMA's expects a developer to first:
%                            \begin{itemize}
%                                    \item declare a type system
%                                    \item configure autogeneration of Java classes from the type system
%                                    \item write an import path for training data
%                                    \item manage parameters for annotator initialization
%                                    \item instantiate the AnalysisEngine for execution
%                                    \item \ldots
%                            \end{itemize}
%                    \item Learning model:
%                            \begin{itemize}
%                                    \item Experts create UIMA scaffold
%                                    \item Allow novices to focus on implementing \code{process} methods and feature extraction
%                            \end{itemize}
%
%            \end{itemize}
%    \end{block}

    \begin{block}{Acknowledgments}
    {
            \scriptsize
            This research was supported in part by the Strategic Health IT Advanced Research Projects (SHARP) Program (90TR002) from the Office of the National Coordinator for Health Information Technology, and by Grant Number R01LM010090 from the National Library Of Medicine. The content is solely the responsibility of the authors and does not necessarily represent the official views of the Office of the National Coordinator for Health Information Technology, the National Library Of Medicine or the National Institutes of Health.
    }

    \end{block}
    
  \end{column}

\end{columns}
\vfill
\end{frame}

\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Local Variables: 
%%% mode: latex
%%% TeX-PDF-mode: t
